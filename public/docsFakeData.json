[
    {
        "id":"01",
        "category": "interview",
        "title": "Interview Preperation & Tips",
        "titleSummury": "An interview is a structured conversation where one participant asks questions, and the other provides answers. In common parlance, the word interview refers to a one-on-one conversation between an interviewer and an interviewee.",
        "question": "Why is preparation important for interview ?",
        "answer": "Being invited to an interview means that your application must have made a good impression. An interview is a discussion between you and an employer to find out if you can do the job. You need to prepare yourself for the interview to make sure that you are successful.",
        "tipsTitle": "10 things you should never do in a job interview",
        "allTips": "1. Be Negetive   It's never a good idea to be critical towards past employers you may have had. Negativity towards previous experiences does not reflect poorly on the organization, but on you. Always be optimistic about past challenges you’ve faced and what you learned from those experiences.   2. Show your nerves   It’s normal to feel nervous during an interview, especially if you’ve been preparing for a while. However coming across as too nervous may be interpreted by the interviewer as you needing to work on the interpersonal skills necessary to thrive in the work environments—be that with other students in the lab or customers for the company. This doesn’t mean you need to be an extrovert—just be confident in yourself and your answers.   3. Lie about anything   It can be tempting to overstate your experience to make you seem more qualified than you are, especially when you feel trapped in a perpetual I need experience to get experience cycle. But exaggerating your qualifications is never a good idea. The risks from doing a job you aren't qualified for is harmful to yourself and others. Some other ways of getting out of this cycle can include volunteering to gain necessary skills, doing workshops, or even taking a course to diversify your skill set!   4. Be arrogant   Don’t get me wrong, it’s important to be confident and enthusiastic during an interview, but appearing arrogant is usually a downfall. There is a fine line between bragging and being confident. No matter how qualified you think you are for the position, nobody owes you the job so stay humble, be respectful, and make sure to thank your interviewer for their time and the opportunity to interview for the position.   5. Dress too casually   While you don’t need to wear a suit and tie to interview at a lab (typically), it's important to present yourself professionally. So no leggings or sweats, no messy hair, and please don’t wear running shoes. How you present yourself reflects on your cleanliness, organization, and work ethic. It shows your interviewer that you're taking this seriously.   6. Show up late   This one speaks for itself. Remember, 10 minutes early is on time. Don’t forget to double-check your interview time and location, and make sure you review how to get there on Google Maps.   7. Leave them hanging   Often at the end of an interview, you'll be asked if you have any questions. Never say (No) This is a great time not only to ask questions about the position and the organization, but also to ask them about the timeline for the (potential) hiring process, reaffirm how qualified and passionate you are, and of course ask any other questions. Don’t forget to thank them for the interview!   8. Display bad body language   Body language is a big reflection of your entire attitude and what you think of the people you're with and the place you're in. Be sure to sit up straight, and make eye contact. Slouching, as well as fiddling around, could show that you’re nervous, uninterested, or arrogant.   9. Forget to do your homework   Make sure you know the position you're applying for through and through. Be ready to talk about how your skills, experience, and attitude fulfill the values and requirements of the position. Make sure you have evidence to back up the fact that you are the one for the job.   10. Ramble on   Although it's important to answer the question with more than one-word responses, rambling on and on for minutes is not recommended. Gather your thoughts and try to articulate them clearly so the interviewer gets the point. Rambling loses their interest and can make them think you don't know what you're talking about. If you feel like you're rambling, stop yourself and ask the interviewer to repeat the question. This will help you get back on track. You could also ask if your response answers their question and they may take the opportunity to elaborate and redirect you."
    },
    {    
        "id":"02",
        "category": "interview",
        "title": "Tell me about yourself?",
        "titleSummury": "This is firest question of an interview. And you must prepare for this question before. You can great impact by answerings this question beautifylly",
        "subTitle": "How To Answer the “Tell Me About Yourself” Interview Question",
        "subTitleSummury": "“Tell me about yourself” might seem like an easy win of an interview question—after all, you know all about yourself! And good thing, too, because it’s often the very first thing an interviewer will ask you to do—whether you’re having a preliminary phone screen, speaking to your prospective boss, or sitting down with the CEO during the final round.   But responding to this invitation to talk about yourself in the context of a job interview can feel stressful and complicated. You might be thinking: Um, what do you want to know? Should I give you the biopic synopsis of my workplace drama complete with ideal casting?   Your interviewer doesn’t need to know you envision Zendaya playing you in the imagined movie adaptation of your life. But you can and should prepare in advance so you can use this common opening prompt to your advantage, setting the stage for a successful interview.",
        "question": "Why interviewers ask you to “Tell me about yourself” ?",
        "answer": "As with any interview question, the key to crafting an impressive answer is understanding why people are asking in the first place.   “It lets them ease into the actual interviewing,” says leadership development coach Alina Campos, founder of Rising. “Often when the conversation starts it’s a lot of small talk and it’s a way to transition into it,” especially for less seasoned recruiters or hiring managers. “The interviewee’s nervous but the interviewer’s trying to get their bearings [too].”   This question is also a great starting point that can help inform the direction of the interview, says Muse career coach and BetterWorks Labs founder Al Dea: “Depending on what you say it’s going to help them figure out the next question,” which might help start a chain effect of follow-up questions, lend an easy flow to the conversation, and help recruiters and hiring managers accomplish one of their major goals in the hiring process: getting to know you.   If you answer it well, the interviewers will begin to find out why you’re the best candidate for this job, in terms of hard skills and experience as well as soft skills. It’s a great opportunity to demonstrate that you can communicate clearly and effectively, connect with and react to other humans, and present yourself professionally.",
        "howTitle": "How to answer “Tell me about yourself”",
        "howTitleSummury1": "1. Remember this is often your first impression, and it matters.   “We really only have one chance to make a first impression,” says Muse career coach and recruiter Steven Davis. “My opinion is that most hiring decisions are made in the first minute,” which includes your greeting, handshake, eye contact, and the first thing you say, which may very well be your response to “Tell me about yourself.”   Even if the powers that be aren’t making an irreversible determination shortly after the conversation begins, a first impression can color the rest of the interview. If you have to spend the rest of the time making up for a bad opening, you’re in a very different position than if you gave a succinct, confident, and relevant answer right off the bat.   “Be prepared for this question and show interviewers you prepared for it,” Campos says. “The confidence that comes across in this is a really good place to start from.”   2. Keep it professional.   As you know by now, this question carries an invisible addendum: “as it’s relevant to this role and company.” So you’re best off keeping your answer professional. The norm in some countries might be to share personal details at this point, Wascovich says, but in the U.S. you should avoid talking about your family and hobbies, for instance, unless you know something very specific about the company that would lead you to believe otherwise.   3. Know your audience.   Learning about the company you're interviewing with ahead of time is crucial. You can tailor your answer to focus on where you align with the company culture and be able to ask more informed questions at the end of the interview.   4. Highlight your personality   Mentioning that you quilt or play chess reveals more about you than just what you do in your spare time, it shows a part of your personality. Interactive roles like volunteer work or being a part of a softball team demonstrate that you are friendly and are able to communicate well with others. ",
        "exampleTitle": "Here are some examples",
        "exampleAnswers": [
            {
                "heading": "Example Answer #1",
                "answer": "I began my career as an administrative assistant working for my current company, but I quickly branched out into marketing. I've always had this way of making better sense of why people need and desire products and services. You could say that I have a knack for understanding the psychology of customers, and using that to point to their needs and specific pain points. I used these skills to advance in my company, making it all the way to marketing director. My goal is to continue to progress in my career."
            },
            {
                "heading": "Example Answer #2",
                "answer": "I'd be glad to share a little about myself. I graduated from XYZ University, where I majored in business administration. During my time at the school I had an internship at a large Fortune 500 company, where I was able to take an active role in their Human Resources department, receiving excellent career advice from mentors. I continued on at that company, up until my current job.   One of the things that I spearheaded at the company was creating a holistic view of employee care. I helped add to the company culture by creating initiatives to create a sense of community, even when we were working remotely. I've sensed that my major passion is to foster a sense of community among employees. My wife and kids have even mentioned how good I am about including them in games and activities. I believe I’m the ideal candidate, as I am passionate about helping you to continue the great work you're doing in human resources."
            },
            {
                "heading": "Example Answer #3",
                "answer": " Throughout my entire career, I have been driven by learning new skills and finding innovative ways to complete my duties. I've always been an avid reader, and consider myself to be a go-getter when it comes to discovering new things. Recently, in the last 5 years, I taught myself how to code, and from there I have had a steady career in the IT field. I have grown leaps and bounds in my technical skills, and this is because I am a lifelong learner who is always willing to humble myself to learn something new."
            }
        ]
    },
    {    
        "id":"03",
        "category": "interview",
        "title": "What is your strength?",
        "subTitle": "Today, we’re tackling another critical job interview question: What are your strengths?",
        "img": "https://resources.biginterview.com/wp-content/uploads/2022/12/How-to-Answer-What-are-your-strengths.jpg",
        "subTitleSummury": "This is a commonly asked question in job interviews – for all levels of positions and in all industries. Even when you’re not asked “What are your strengths?”, you still must be prepared to answer the question well in order to land the job. After all, from the employer’s perspective, the main point of a job interview is to understand what you could do for the organization and why they should hire you instead of someone else. Although this question comes up in 80% of interviews, many candidates don’t know how to answer it. This means there’s a real opportunity for you to stand out from the crowd if you can speak about your strengths in an authentic and compelling way.",
        "question": "Why Do Interviewers Ask This Question?",
        "answer": "It’s the interviewer’s job to find someone who will perform in the position and get along with the team. This question can be phrased in several ways:   Your strengths align with the company’s needs   You can do the job and perform like a rock star   You are the best person for the job — no need to hold out for someone better   You have qualities, skills, and/or experience that set you apart from the competition   You are someone who will make an excellent addition to the team",
        "howTitle": "How to Talk About Your Strengths",
        "howTitleSummury1": "Some people think this is an easy question. This question is a prompt for you to brag and “sell” yourself as the best fit for the job. So how could you mess it up? You know yourself, right? Unfortunately, many candidates don’t have a clear sense of their job-related strengths.",
        "howTitleSummury2": "1. Brainstorm   Sit down and make a personal strengths list — aim for at least 10 and be creative. Jot down everything that comes to mind. You can always delete or modify later.   Your strengths could include:   Experience — Experience with a certain software or type of task, expertise in a particular industry, a track record of working with similar products or clients, etc.   Talents — Abilities such as programming in a desired language, writing proposals, selling widgets, litigating cases, organizing events, translating from Mandarin, etc. (the possibilities here are truly endless).   Soft skills — Competencies such as problem-solving, influencing, team building, negotiation, managing up, etc.   2. Prepare examples   Develop at least one example or interview story to illustrate each of your strengths. If you’re not sure how to go about crafting compelling stories and examples from your previous experience, scroll down to find some examples that work. Having a concise example or story ready to back each strength up is crucial here. Be careful about rambling. Your answer should still be 1-2 minutes long. If you want to share three strengths and back each up with an example, you will want to practice answering interview questions in advance so that you can do it in a concise and effective way.   3. Be accurate, relevant, and show self-awareness   Make sure to choose the strengths that you actually possess and avoid being too generic. Instead of “people skills” (too broad and boring), go with “relationship building” or “persuasive communication.” You should take the time to analyze the job description and identify the most important strengths for each opportunity. You likely have many strengths, but which will be most relevant for this interviewer? Always try to match your strengths with the requirements of the position you’re applying for. A common mistake here is to choose a lame strength that doesn’t really help you stand out. These are either strengths that are hardly relevant to the job at hand or weak strengths that just about anyone could claim. This mistake makes a candidate bland and forgettable at best. At worst, you can raise red flags with the interviewer — who wants to hire someone whose greatest strength is the ability to show up on time?   4. Don’t be too humble   Many candidates are too humble or just aren’t comfortable articulating what makes them great. This is particularly true for introverts and/or people who never really had to “sell” themselves before because new jobs always fell in their laps in the past. You have to get over any hesitation to say nice things about yourself (That’s why practicing your answers is so crucial!). You can do it in a way that feels comfortable and authentic if you prepare in advance.",
        "exampleTitle": "Examples of the Best Answers",
        "exampleSummury1": "Review these examples of the best answers to questions about your strengths but be sure to tailor your responses to your credentials and the job requirements.",
        "exampleAnswers": [
            {
                "heading": "Example Answer #1",
                "answer": " I have a solid work ethic. When I'm working on a project, I don't just want to meet deadlines. Rather, I prefer to complete the project well ahead of schedule. Last year, I even earned a bonus for completing my three most recent reports one week ahead of time."
            },
            {
                "heading": "Example Answer #2",
                "answer": "I have extremely strong writing skills. Having worked as a copy editor for five years, I have a deep attention to detail when it comes to my writing. I have also written for a variety of publications, so I know how to shape my writing style to fit the task and audience. As a marketing assistant, I will be able to write and edit press releases effectively and update web content with accuracy and ease."
            },
            {
                "heading": "Example Answer #3",
                "answer": "I am a skilled sales representative with over 10 years of experience. I have exceeded my sales goals every quarter by at least 20%, and I've earned a bonus each year since I started with my current employer."
            }
        ]
    },
    {
        "id":"04",
        "category": "interview",
        "title": "Why should we hire you ?",
        "subTitle": "How to Answer “Why Should We Hire You?”",
        "subTitleSummury": "“Why should we hire you?” is still one of the most common, and yet difficult job interview questions in 2023.   What makes it so tough is that it’s a very open-ended question, and can be answered in a number of different ways.   You can, for example, go over your resume and explain how your work experience makes you a great fit for the role.   You can, for example, go over your resume and explain how your work experience makes you a great fit for the role.   Alternatively, you can talk about how you possess certain skills that make you stand out from other candidates.   In this article, we’re going to teach you 10 different answers you can give to this complicated job interview question!",
        "question": "Why Do Interviewers Ask “Why Should We Hire You?” ",
        "answer": "When the interviewer asks “why should we hire you?”, they want to measure exactly how qualified you are for the job and what makes you a good fit for the company.   Your work experience and achievements. You can talk about a specific accomplishment at a previous, relevant position and show the interviewer how you can achieve similar results for them.   Your skills and qualifications. If you can prove that you’ve got all the skills that the company is looking for in a candidate, you’ll have effectively answered the question.   Your passion and motivation. You can highlight how good of a company fit you’d be and how much you love working in your field or industry. When it comes to choosing between two applicants with similar skills and work experience, the employer will always go for the one who’s more motivated, sociable, and able to fit in with the company culture. So, talking about your passions and motivations can take you a long way!",
        "howTitle": "How to Answer “Why Should We Hire You?”",
        "howTitleSummury1": "Now that we’ve covered the basics, let’s talk about tips! There are 3 main tricks to getting this job interview question right, starting with: ",
        "howTitleSummury2": "1. Show off your skills and experience   The first thing you should do when answering “why should we hire you?” is to highlight any skills and professional experience that are relevant to the position you’re applying for.   To make your answer all the more valid, make sure to always back up everything you say with examples, experiences, and achievements.   2. Highlight your ability to fit in and work in a team   Teamwork skills and adaptability comes in handy for practically every position out there.   No matter your profession, you’ll likely need to work alongside others and adapt to different people and situations, so these are two skills that employers are always on the lookout for.   Even if you’re a novelist - a predominantly solitary profession - you’ll still need to work with your publisher, a team of editors, and book designers to create a good book.   So, convincing the interviewer that you can adapt to the work environment, your colleagues, and even your supervisors, is an important part of answering “why should we hire you?”   3. Explain how you can help the company do more   At the end of the day, the goal of every job is to help an organization achieve a certain goal.   If you’re applying for a job in marketing, for example, your goal might be to generate leads. If you’re in customer support, it’s to provide excellent service to the company’s clients   As such, one way to answer “why should we hire you?” is by explaining how, exactly, you can help the company achieve such a goal through your experience and skills.   Let’s say that you’re applying for a role as an event planner at a small company. From reading the job description, you know they’re looking for someone to organize events in their area and get the company’s name out there.   Now you have a clear understanding of what the company’s #1 goal in hiring you is! They want to find someone who can organize events successfully, promote the said events, and improve the company's brand awareness.   Now, when answering “why should we hire you,” you can explain how exactly you’ll be able to fulfill the company's goals.",
        "exampleTitle": "A general answer to “Why Should I Hire You”",
        "exampleAnswers": [
            {
                "heading": "Possible Answer #1",
                "answer": " “Over the years, I have acquired relevant skills and experience, which I shall bring to your organization.   I have also worked tirelessly on my communication abilities and teamwork skills, which I will put to use in my future career, which would be in your organization if I am selected for the position.   I have given my 100% effort in my past companies, and this has enabled me to recognize my capabilities and limitations.   If I channelize them further, they will bring fruitful results to me and also to your esteemed organization.”"
            },
            {
                "heading": "Possible Answer #2",
                "answer": " “This is a wonderful opportunity for me to get interviewed at such a renowned company.   Your organization will surely prove to be an excellent platform for me to establish my skills and knowledge in the corporate world.   Even though I am a fresher, I assure you that I will give my best and work to my full potential so that I can contribute as much as I can towards the growth and welfare of this great brand.”"
            },
            {
                "heading": "Possible Answer #3",
                "answer": "“Honestly, I possess all the skills and experience that you’re looking for. I’m pretty confident that I am the best candidate for this job role.   It’s not just my background in the past projects, but also my people skills, which will be applicable in this position.   On the other hand, I am a self motivated person and I try to exceed my superior’s expectations with high-quality work. Being a fast learner, I quickly pick up business knowledge related to my project.   Lastly, I would like to add that I work well both as an individual contributor and also as a team member.   Collectively, all these skills put together makes me a complete package for this job.”"
            },
            {
                "heading": "Possible Answer #4",
                "answer": "“I feel that I should be hired by you given my excellent academic background along with the skills and experience the company is looking for.   I have the experience and the attitude to excel. If given a chance, I will surely work towards building my expertise, which would prove beneficial for me as well as your organization.”"
            }
        ]
    },
    {
        "id":"05",
        "category": "error",
        "title": "Error",
        "titleSummury": "There is no developer who has not faced errors in his/her development life. When we get error that means we make a mistakes and we should find out it with cool head but many of the developer became nervious when getting error. Always remember if you want to be a professional developer you must learn how to handle error easily because it's a speciality of a developer.",
        "subTitle": "Error types",
        "subTitleSummury": "Besides the generic Error constructor, there are other core error constructors in JavaScript. For client-side exceptions, see Exception handling statements.",
        "errorTypes": "EvalError   Creates an instance representing an error that occurs regarding the global function eval().   RangeError   Creates an instance representing an error that occurs when a numeric variable or parameter is outside its valid range.   ReferenceError   Creates an instance representing an error that occurs when de-referencing an invalid reference.   SyntaxError   Creates an instance representing a syntax error.   TypeError   Creates an instance representing an error that occurs when a variable or parameter is not of a valid type.   URIError   Creates an instance representing an error that occurs when encodeURI() or decodeURI() are passed invalid parameters.   AggregateError   Creates an instance representing several errors wrapped in a single error when multiple errors need to be reported by an operation, for example by Promise.any().",
        "exampleTitle": "Examples",
        "subExampleTitle": "Throwing a generic error",
        "subExampleTitleSummury": "Usually you create an Error object with the intention of raising it using the throw keyword. You can handle the error using the try...catch construct:",
        "code": "try   {throw new Error('Whoops!');   } catch (e) {   console.error(`${e.name }: ${e.message}`);   }",
        "quiz": {
            "title": "Why we got error ?",
            "options": [
                {
                    "optionOne": "Because I am a junior developer"
                },
                {
                    "optionTwo": "Because I am a React developer"
                },
                {
                    "optionThree": "When we mistake in our code"
                },
                {
                    "optionFour": "Both 1 & 2"
                }
            ]
        }
    },
    {
        "id":"06",
        "category": "error",
        "title": "Syntax Error",
        "titleSummury": "During the syntax analysis phase, this type of error appears. Syntax error is found during the execution of the program.   Some syntax error can be:   Error in structure   Missing operators   Unbalanced parenthesis",
        "question": "Why this error occur ?",
        "answer": "A syntax error occurs when a programmer writes an incorrect line of code. Most syntax errors involve missing punctuation or a misspelled name. If there is a syntax error in a compiled or interpreted programming language, then the code won't work.   When an invalid calculation enters into a calculator then a syntax error can also occurs. This can be caused by entering several decimal points in one number or by opening brackets without closing them.   For example 1: Using '=' when '==' is needed.",
        "exampleTitle": "For Examples",
        "code": "int a;   print('value of variable a is',a)   Here, ';' is missing from the print statement."
    },
    {
        "id":"07",
        "category": "error",
        "title": "Uncaught Type Error",
        "img": "http://net-informations.com/js/iq/img/type-error.png",
        "titleSummury": "According to the Mozilla website for developer documents, “the TypeError object represents an error when a value is not of the expected type.” Uncaught means that the error was not caught in the catch part of the try-catch block.",
        "question": "Why this error occur ?",
        "answer": "A TypeError may be thrown when:   an operand or argument passed to a function is incompatible with the type expected by that operator or function; or   when attempting to modify a value that cannot be changed; or   when attempting to use a value in an inappropriate way.",
        "exampleTitle": "Examples",
        "subExampleTitle": "Catching a TypeError",
        "code": "try {   null.f()   } catch (e) {   console.log(e instanceofTypeError) // true   console.log(e.message) // null has nopropertie   console.log(e.name) // TypeError   console.log(e fileName) // Scratchpad/1   console.log(e.lineNumber) // 2   console.log(e.columnNumber) // 2console.log(e.stack) // @Scratchpad2:2:3\n}"
    },
    {
        "id":"08",
        "category": "error",
        "title": "Reference Error",
        "titleSummury": "When programming in JavaScript, you’ll commonly encounter reference errors. There are a number of reasons why you might get one, but fortunately, resolving such an error isn’t too difficult. It’s helpful to know what this error is and why it’s being thrown by the compiler because you’ll save yourself precious debugging time.   In this guide to JavaScript reference errors, you’ll learn how to identify and solve them as well as how to avoid this type of error in the future.",
        "question": "Why You Need to Understand Reference Errors",
        "answer": "It’s important that you understand why JavaScript might throw such an error, especially for the following reasons:   - If you understand what’s going on and why, the error is easier and quicker to fix.   - It is possible to catch this type of error at build time if your code is properly structured.   - If you spend less time trying to understand why the error occurred, you can spend more time on programming, which improves your workflow.",
        "exampleTitle": "Examples",
        "subExampleTitle": "Undeclared or Undefined Variable",
        "subExampleTitleSummury": "When a variable reference cannot be found or is not declared, it causes a reference error. New developers are most likely to commit reference errors by forgetting to define variables before referencing them. Here’s an example:",
        "code": "const a = 'Apple'   console.log(a)   // ReferenceError a is not defined."
    },
    {
        "id":"09",
        "title": "Getting Started",
        "category": "installation",
        "titleSummury":"This page is an overview of the React documentation and related resources.React is a JavaScript library for building user interfaces Learn what React is all about on our homepage or in the tutorial.",
        "titleSummuryYellow": "Try the new React documentation.The new Quick Start teaches modern React and includes live examples.The new docs will soon replace this site, which will be archived. Provide feedback.",
        "question":"Try React",
        "answer":"React has been designed from the start for gradual adoption, and you can use as little or as much React as you need. Whether you want to get a taste of React, add some interactivity to a simple HTML page, or start a complex React-powered app, the links in this section will help you get started.",
        "allTips":"1. Online Playgrounds   If you’re interested in playing around with React, you can use an online code playground. Try a Hello World template on CodePen, CodeSandbox, or Stackblitz.If you prefer to use your own text editor, you can also download this HTML file, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation,so we’d only recommend using this for simple demos.   2. Add React to a Website   You can add React to an HTML page in one minute. You can then either gradually expand its presence, or keep it contained to a few dynamic widgets.   3. Create a New React App   When starting a React project, a simple HTML page with script tags might still be the best option. It only takes a minute to set up!As your application grows, you might want to consider a more integrated setup. There are several JavaScript toolchains we recommend for larger applications. Each of them can work with little to no configuration and lets you take full advantage of the rich React ecosystem.",
        "howTitle":"Learn React",
        "howTitleSummury1":"People come to React from different backgrounds and with different learning styles. Whether you prefer a more theoretical or a practical approach, we hope you’ll find this section helpful.",
        "howTitleSummury2":"1. First Examples   The React homepage contains a few small React examples with a live editor. Even if you don’t know anything about React yet, try changing their code and see how it affects the result.   2. React for Beginners   If you feel that the React documentation goes at a faster pace than you’re comfortable with, check out this overview of React by Tania Rascia. It introduces the most important React concepts in a detailed, beginner-friendly way. Once you’re done, give the documentation another try!   3. React for Designers   If you’re coming from a design background, these resources are a great place to get started.   4. JavaScript Resources   The React documentation assumes some familiarity with programming in the JavaScript language. You don’t have to be an expert, but it’s harder to learn both React and JavaScript at the same time. We recommend going through this JavaScript overview to check your knowledge level. It will take you between 30 minutes and an hour but you will feel more confident learning React."

        
    },
    {
        "id":"10",
        "title": "Create a New React App",
        "category": "installation",
        "titleSummuryYellow": "Use an integrated toolchain for the best user and developer experience.This page describes a few popular React toolchains which help with tasks like:Scaling to many files and components.Using third-party libraries from npm.Detecting common mistakes early.Live-editing CSS and JS in development.Optimizing the output for production.",
        "question":"You Might Not Need a Toolchain",
        "answer":"If you don’t experience the problems described above or don’t feel comfortable using JavaScript tools yet, consider adding React as a plain <script> tag on an HTML page,optionally with JSX.This is also the easiest way to integrate React into an existing website. You can always add a larger toolchain if you find it helpful!",
        "howTitle":"Recommended Toolchains",
        "howTitleSummury1":"The React team primarily recommends these solutions:   If you’re learning React or creating a new single-page app, use Create React App.If you’re building a server-rendered website with Node.js, try Next.js.If you’re building a static content-oriented website, try Gatsby.If you’re building a component library or integrating with an existing codebase, try More Flexible Toolchains.",
        "howTitleSummury2":"1. Create React App   Create React App is a comfortable environment for learning React, and is the best way to start building a new single-page application in React.It sets up your development environment so that you can use the latest JavaScript features,provides a nice developer experience, and optimizes your app for production.   2. Next.js   Next.js is a popular and lightweight framework for static and server‑rendered applicationsbuilt with React. It includes styling and routing solutions out of the box, and assumes that you’re using Node.js as the server environment.Learn Next.js from its official guide.   3. Gatsby   Gatsby is the best way to create static websites with React. It lets you use React components,but outputs pre-rendered HTML and CSS to guarantee the fastest load time.Learn Gatsby from its official guide and a gallery of starter kits.   4. More Flexible Toolchains   The following toolchains offer more flexibility and choice. We recommend them to more experienced users:   Neutrino combines the power of webpack with the simplicity of presets, and includes a preset for React apps and React components.Nx is a toolkit for full-stack monorepo development, with built-in support for React, Next.js, Express, and more.   Parcel is a fast, zero configuration web application bundler that works with React.Razzle is a server-rendering framework that doesn’t require any configuration, but offers more flexibility than Next.js."
    },
    {
        "id":"11",
        "title": "CDN Links",
        "category": "installation",
        "titleSumm": "Both React and ReactDOM are available over a CDN.",
        "code1":"<script crossorigin src='https://unpkg.com/react@18/umd/react.development.js'></script>   <script crossorigin src='https://unpkg.com/react-dom@18/umd/react-dom.development.js'></script>",
        "description":"The versions above are only meant for development, and are not suitable for production.   Minified and optimized production versions of React are available at:",
        "code2":"<script crossorigin src='https://unpkg.com/react@18/umd/react.production.min.js'></script>   <script crossorigin src='https://unpkg.com/react-dom@18/umd/react-dom.production.min.js'></script>",
        "description1":"To load a specific version of react and react-dom, replace 18 with the version number",
        "dTitle":"Why the crossorigin Attribute?",
        "descrption2":"If you serve React from a CDN, we recommend to keep the crossorigin attribute set:",
        "code3":"<script crossorigin src='...'></script>"

    },
    {
        "id":"12",
        "title": "Release Channels",
        "category": "installation",
        "titleSummury":"React relies on a thriving open source community to file bug reports, open pull   requests, and submit RFCs. To encourage feedback we sometimes share special   builds of React that include unreleased features.",
        "titleSummuryYellow": "Try the new React documentation.The new Quick Start teaches modern React and includes live examples.The new docs will soon replace this site, which will be archived. Provide feedback.",
        "howTitleSummury2":"1. Latest Channel   Latest is the channel used for stable React releases. It corresponds to the latest tag on npm.It is the recommended channel for all React apps that are shipped to real users.If you’re not sure which channel you should use, it’s Latest. If you’re a React developer, this is what you’re already using.You can expect updates to Latest to be extremely stable.Versions follow the semanticversioning scheme. Learn more about our commitment to stability and incremental migration in our versioning policy.   2. Next Channel   The Next channel is a prerelease channel that tracks the main branch of the React repository.We use prereleases in the Next channel as release candidates for the Latest channel. You canthink of Next as a superset of Latest that is updated more frequently.The degree of change between the most recent Next release and the most recent Latestrelease is approximately the same as you would find between two minor semver releases.However, the Next channel does not conform to semantic versioning. You should expect occasional breaking changes between successive releases in the Next channel.   3. Experimental Channel   Like Next, the Experimental channel is a prerelease channel that tracks the main branch of the React repository. Unlike Next, Experimental releases include additional features and APIs that are not ready for wider release. Usually, an update to Next is accompanied by a corresponding update to Experimental. They are based on the same source revision, but are built using a different set of feature flags."

    },
    {
        "id":"13",
        "category": "MAIN CONCEPTS",
        "title": "Hello World",
        "first": "The smallest React example looks like this:",
        "secondBlack": "const root = ReactDOM.createRoot(document.getElementById('root'));   root.render(<h1>Hello, world!</h1>);",
        "third": "It displays a heading saying “Hello, world!” on the page.   Try it on CodePen   Click the link above to open an online editor. Feel free to make some changes, and see how they affect the output. Most pages in this guide will have editable examples like this one.",
        "forthHeader": "How to Read This Guide",
        "fifth": "In this guide, we will examine the building blocks of React apps: elements and components. Once you master them, you can create complex apps from small reusable pieces.",
        "sixthYellow": "Tip   This guide is designed for people who prefer learning concepts step by step. If you prefer to learn by doing, check out our practical tutorial. You might find this guide and the tutorial complementary to each other.",
        "seventh": "This is the first chapter in a step-by-step guide about main React concepts. You can find a list of all its chapters in the navigation sidebar. If you’re reading this from a mobile device, you can access the navigation by pressing the button in the bottom right corner of your screen",
        "eighth": "Every chapter in this guide builds on the knowledge introduced in earlier chapters. You can learn most of React by reading the “Main Concepts” guide chapters in the order they appear in the sidebar. For example, “Introducing JSX” is the next chapter after this one.",
        "ninethHeader": "Knowledge Level Assumptions",
        "tenth": "React is a JavaScript library, and so we’ll assume you have a basic understanding of the JavaScript language. If you don’t feel very confident, we recommend going through a JavaScript tutorial to check your knowledge level and enable you to follow along this guide without getting lost. It might take you between 30 minutes and an hour, but as a result you won’t have to feel like you’re learning both React and JavaScript at the same time.",
        "eleventhYellow": "Note   This guide occasionally uses some newer JavaScript syntax in the examples. If you haven’t worked with JavaScript in the last few years, these three points should get you most of the way."
    },
    {
        "category": "MAIN CONCEPTS",
        "title": "Introducing JSX",
        "firstYellow": "Try the new React documentation.   These new documentation pages teach modern React and include live examples:   Writing Markup with JSX   JavaScript in JSX with Curly Braces   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "second": "Consider this variable declaration:",
        "thirdBlack": "const element = <h1>Hello, world!</h1>;",
        "forth": "This funny tag syntax is neither a string nor HTML.   It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.   JSX produces React “elements”. We will explore rendering them to the DOM in the next section. Below, you can find the basics of JSX necessary to get you started.",
        "fifthHeader": "Why JSX?",
        "sixth": "React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.",
        "seventh": "Instead of artificially separating technologies by putting markup and logic in separate files, React separates concerns with loosely coupled units called “components” that contain both. We will come back to components in a further section, but if you’re not yet comfortable putting markup in JS, this talk might convince you otherwise.",
        "eighth": "React doesn’t require using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.   With that out of the way, let’s get started!",
        "ninethHeader": "Embedding Expressions in JSX",
        "tenth": "In the example below, we declare a variable called name and then use it inside JSX by wrapping it in curly braces:",
        "eleventhBlack": "const name = 'Josh Perez';   const element = <h1>Hello{name}</h1>;",
        "twelve": "You can put any valid JavaScript expression inside the curly braces in JSX. For example, 2 + 2, user.firstName, or formatName(user) are all valid JavaScript expressions.   In the example below, we embed the result of calling a JavaScript function, formatName(user), into an <h1> element.",
        "thirteenBlack": "function formatName(user) {   return user.firstName + ' ' + user.lastName;   }   const user = {   firstName: 'Harper',   lastName: 'Perez'   };   const element = (   <h1>   Hello, {formatName(user)}!   </h1>   );"
    },
    {
        "category": "MAIN CONCEPTS",
        "title": "Rendering Elements",
        "first": "Elements are the smallest building blocks of React apps.",
        "second": "An element describes what you want to see on the screen:",
        "thirdBlack": "const element = <h1>Hello, world</h1>;",
        "forth": "Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.",
        "fifthYellow": "Nodes   One might confuse elements with a more widely known concept of “components”. We will introduce components in the next section. Elements are what components are “made of”, and we encourage you to read this section before jumping ahead.",
        "sisthHeader": "Rendering an Element into the DOM",
        "seventh": "Let’s say there is a <div> somewhere in your HTML file:",
        "eighthBlack": "<div id='root'></div>",
        "nineth": "We call this a “root” DOM node because everything inside it will be managed by React DOM.   Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.   To render a React element, first pass the DOM element to ReactDOM.createRoot(), then pass the React element to root.render():",
        "tenthBlack": "const root = ReactDOM.createRoot(   document.getElementById('root')   );   const element = <h1>Hello, world</h1>;   root.render(element);",
        "eleventh": "It displays “Hello, world” on the page.",
        "twelveHeader": "Updating the Rendered Element",
        "thirteen": "React elements are immutable. Once you create an element, you can’t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.",
        "fourteenHeader": "With our knowledge so far, the only way to update the UI is to create a new element, and pass it to root.render().   Consider this ticking clock example:",
        "fifteenBlack": "const root = ReactDOM.createRoot(   document.getElementById('root')   );   function tick() {   const element = (   <div>   <h1>Hello, world!</h1>   <h2>It is {new Date().toLocaleTimeString()}.</h2>   </div>   );   root.render(element);   }   setInterval(tick, 1000);",
        "sixteen": "It calls root.render() every second from a setInterval() callback.",
        "seventeenYellow": "Note:   In practice, most React apps only call root.render() once. In the next sections we will learn how such code gets encapsulated into stateful components.   We recommend that you don’t skip topics because they build on each other."
    },
    {
        "category": "MAIN CONCEPTS",
        "title": "Components and Props",
        "firstYellow": "Try the new React documentation.   These new documentation pages teach modern React and include live examples:   Your First Component   Passing Props to a Component   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "second": "Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. This page provides an introduction to the idea of components. You can find a detailed component apireference here.",
        "third": "Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.",
        "forthHeader": "Function and Class Components",
        "fifth": "The simplest way to define a component is to write a JavaScript function:",
        "sixthBlack": "function Welcome(props) {   return <h1>Hello, {props.name}</h1>;   }",
        "seventh": "This function is a valid React component because it accepts a single “props” (which stands for properties) object argument with data and returns a React element. We call such components “function components” because they are literally JavaScript functions.",
        "eighth": "You can also use an ES6 class to define a component:",
        "ninethBlack": "class Welcome extends React.Component {   render() {   return <h1>Hello, {this.props.name}</h1>;   }   }",
        "tenth": "The above two components are equivalent from React’s point of view.",
        "eleventh": "Function and Class components both have some additional features that we will discuss in the next sections.",
        "twelveHeader": "Rendering a Component",
        "thirteen": "Previously, we only encountered React elements that represent DOM tags:",
        "fourteenBlack": "const element = <div />;",
        "fifteen": "However, elements can also represent user-defined components:",
        "sixteenBlack": "const element = <Welcome name='Sara' />;",
        "seventeen": "When React sees an element representing a user-defined component, it passes JSX attributes and children to this component as a single object. We call this object “props”.   For example, this code renders “Hello, Sara” on the page:",
        "eighteenBlack": "function Welcome(props) {   return <h1>Hello, {props.name}</h1>;   }   const root = ReactDOM.createRoot(document.getElementById('root'));   const element = <Welcome name='Sara' />;   root.render(element);"
    },
    {
        "category": "MAIN CONCEPTS",
        "title": "State and Lifecycle",
        "firstYellow": "Try the new React documentation.   These new documentation pages teach modern React and include live examples:   State: A Component’s Memory   Synchronizing with Effects   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "second": "This page introduces the concept of state and lifecycle in a React component. You can find a detailed component apireference here.",
        "third": "Consider the ticking clock example from one of the previous sections. In Rendering Elements, we have only learned one way to update the UI. We call root.render() to change the rendered output:",
        "forthBlack": "const root = ReactDOM.createRoot(document.getElementById('root'));   function tick() {   const element = (   <div>   <h1>Hello, world!</h1>   <h2>It is {new Date().toLocaleTimeString()}.</h2>   </div>   );   root.render(element);   }   setInterval(tick, 1000);",
        "fifth": "Try it on CodePen",
        "sixth": "In this section, we will learn how to make the Clock component truly reusable and encapsulated. It will set up its own timer and update itself every second.   We can start by encapsulating how the clock looks:",
        "seventhBlack": "const root = ReactDOM.createRoot(document.getElementById('root'));   function Clock(props) {   return (   <div>   <h1>Hello, world!</h1>   <h2>It is {props.date.toLocaleTimeString()}.</h2>   </div>   );   }   function tick() {   root.render(<Clock date={new Date()} />);   }   setInterval(tick, 1000);",
        "eighth": "Try it on CodePen",
        "nineth": "However, it misses a crucial requirement: the fact that the Clock sets up a timer and updates the UI every second should be an implementation detail of the Clock.   Ideally we want to write this once and have the Clock update itself:",
        "tenthBlack": "root.render(<Clock />);",
        "eleventh": "To implement this, we need to add “state” to the Clock component.   State is similar to props, but it is private and fully controlled by the component.",
        "twelveHeader": "Converting a Function to a Class",
        "thirteen": "You can convert a function component like Clock to a class in five steps:",
        "fourteenNumber": "Create an ES6 class, with the same name, that extends React.Component.   Add a single empty method to it called render().   Move the body of the function into the render() method.   Replace props with this.props in the render() body.   Delete the remaining empty function declaration.",
        "fifteenBlack": "class Clock extends React.Component {   render() {   return (   <div>   <h1>Hello, world!</h1>   <h2>It is {this.props.date.toLocaleTimeString()}.</h2>   </div>   );   }   }",
        "sixteen": "Try it on CodePen",
        "seventeen": "Clock is now defined as a class rather than a function.",
        "eighteen": "The render method will be called each time an update happens, but as long as we render <Clock /> into the same DOM node, only a single instance of the Clock class will be used. This lets us use additional features such as local state and lifecycle methods."
    },
    {
        "category":"MAIN CONCEPTS",
        "title": "Handling Events",
        "firstYellow": "Try the new React documentation.   These new documentation pages teach modern React and include live examples:   Responding to Events   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "second": "Handling events with React elements is very similar to handling events on DOM elements. There are some syntax differences:",
        "thirdBullet": "React events are named using camelCase, rather than lowercase.   With JSX you pass a function as the event handler, rather than a string.",
        "forth": "For example, the HTML:",
        "fifthBlack": "<button onclick='activateLasers()'>   Activate Lasers   </button>",
        "sixth": "is slightly different in React:",
        "seventhBlack": "<button onClick={activateLasers}>   Activate Lasers   </button>",
        "eighth": "Another difference is that you cannot return false to prevent default behavior in React. You must call preventDefault explicitly. For example, with plain HTML, to prevent the default form behavior of submitting, you can write:",
        "ninethBlack": "<form onsubmit='console.log('You clicked submit.'); return false'>   <button type='submit'>Submit</button>   </form>",
        "tenth": "In React, this could instead be:",
        "eleventhBlack": "function Form() {   function handleSubmit(e) {   e.preventDefault();   console.log('You clicked submit.');   }   return (   <form onSubmit={handleSubmit}>   <button type='submit'>Submit</button>   </form>   );   }",
        "twelve": "Here, e is a synthetic event. React defines these synthetic events according to the W3C spec, so you don’t need to worry about cross-browser compatibility. React events do not work exactly the same as native events. See the SyntheticEvent reference guide to learn more.",
        "thirteen": "When using React, you generally don’t need to call addEventListener to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.",
        "fourteen": "When you define a component using an ES6 class, a common pattern is for an event handler to be a method on the class. For example, this Toggle component renders a button that lets the user toggle between “ON” and “OFF” states:",
        "fifteenBlack": "class Toggle extends React.Component {   constructor(props) {   super(props);   this.state = {isToggleOn: true};   // This binding is necessary to make `this` work in the callback   this.handleClick = this.handleClick.bind(this);   }   handleClick() {   this.setState(prevState => ({   isToggleOn: !prevState.isToggleOn   }));   }   render() {   return (   <button onClick={this.handleClick}>   {this.state.isToggleOn ? 'ON' : 'OFF'}   </button>   );   }   }",
        "sixteen": "Try it on CodePen",
        "seventeen": "You have to be careful about the meaning of this in JSX callbacks. In JavaScript, class methods are not bound by default. If you forget to bind this.handleClick and pass it to onClick, this will be undefined when the function is actually called.",
        "eighteen": "This is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method.",
        "nineteen": "If calling bind annoys you, there are two ways you can get around this. You can use public class fields syntax to correctly bind callbacks:",
        "twentyBlack": "class LoggingButton extends React.Component {   // This syntax ensures `this` is bound within handleClick.   handleClick = () => {   console.log('this is:', this);   };   render() {   return (   <button onClick={this.handleClick}>   Click me   </button>   );   }   }",
        "twentyOne": "This syntax is enabled by default in Create React App.",
        "twentyTwo": "f you aren’t using class fields syntax, you can use an arrow function in the callback:"
    },
    {
        "category":"MAIN CONCEPTS",
        "title": "Conditional Rendering",
        "firstYellow": "Try the new React documentation.   These new documentation pages teach modern React and include live examples:   Conditional Rendering   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "second": "In React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.",
        "third": "Conditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like if or the conditional operator to create elements representing the current state, and let React update the UI to match them.",
        "forth": "Consider these two components:",
        "fifthBlack": "function UserGreeting(props) {   return <h1>Welcome back!</h1>;   }   function GuestGreeting(props) {   return <h1>Please sign up.</h1>;   }",
        "sixth": "We’ll create a Greeting component that displays either of these components depending on whether a user is logged in:",
        "seventhBlack": "function Greeting(props) {   const isLoggedIn = props.isLoggedIn;   if (isLoggedIn) {   return <UserGreeting />;   }   return <GuestGreeting />;   }   const root = ReactDOM.createRoot(document.getElementById('root'));   // Try changing to isLoggedIn={true}:   root.render(<Greeting isLoggedIn={false} />);",
        "eighth": "Try it on CodePen",
        "nineth": "This example renders a different greeting depending on the value of isLoggedIn prop.",
        "tenthHeader": "Element Variables",
        "eleventh": "You can use variables to store elements. This can help you conditionally render a part of the component while the rest of the output doesn’t change.",
        "twelve": "Consider these two new components representing Logout and Login buttons:",
        "thirteenBlack": "function LoginButton(props) {   return (   <button onClick={props.onClick}>   Login   </button>   );   }   function LogoutButton(props) {   return (   <button onClick={props.onClick}>   Logout   </button>   );   }",
        "fourteen": "In the example below, we will create a stateful component called LoginControl.",
        "fifteen": "It will render either <LoginButton /> or <LogoutButton /> depending on its current state. It will also render a <Greeting /> from the previous example:",
        "sixteenBlack": "class LoginControl extends React.Component {   constructor(props) {   super(props);   this.handleLoginClick = this.handleLoginClick.bind(this);   this.handleLogoutClick = this.handleLogoutClick.bind(this);   this.state = {isLoggedIn: false};   }   handleLoginClick() {   this.setState({isLoggedIn: true});   }   handleLogoutClick() {   this.setState({isLoggedIn: false});   }   render() {   const isLoggedIn = this.state.isLoggedIn;   let button;   if (isLoggedIn) {   button = <LogoutButton onClick={this.handleLogoutClick} />;   } else {   button = <LoginButton onClick={this.handleLoginClick} />;   }   return (   <div>   <Greeting isLoggedIn={isLoggedIn} />   {button}   </div>   );   }   }   const root = ReactDOM.createRoot(document.getElementById('root'));   root.render(<LoginControl />);",
        "seventeen": "Try it on CodePen",
        "eighteen": "While declaring a variable and using an if statement is a fine way to conditionally render a component, sometimes you might want to use a shorter syntax. There are a few ways to inline conditions in JSX, explained below."
    },
    {
        "category":"MAIN CONCEPTS",
        "title": "Lists and Keys",
        "firstYellow": "Try the new React documentation.   These new documentation pages teach modern React and include live examples:   Rendering Lists   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "second": "First, let’s review how you transform lists in JavaScript.",
        "third": "Given the code below, we use the map() function to take an array of numbers and double their values. We assign the new array returned by map() to the variable doubled and log it:",
        "forthBlack": "const numbers = [1, 2, 3, 4, 5];   const doubled = numbers.map((number) => number * 2);   console.log(doubled);",
        "fifth": "This code logs [2, 4, 6, 8, 10] to the console.",
        "sixth": "In React, transforming arrays into lists of elements is nearly identical.",
        "seventhHeader": "Rendering Multiple Components",
        "eighth": "You can build collections of elements and include them in JSX using curly braces {}.",
        "nineth": "Below, we loop through the numbers array using the JavaScript map() function. We return a <li> element for each item. Finally, we assign the resulting array of elements to listItems:",
        "tenthBlack": "const numbers = [1, 2, 3, 4, 5];   const listItems = numbers.map((number) =>   <li>{number}</li>   );",
        "eleventh": "Then, we can include the entire listItems array inside a <ul> element:",
        "twelveBlack": "<ul>{listItems}</ul>",
        "thirteen": "Try it on CodePen   This code displays a bullet list of numbers between 1 and 5.",
        "fourteenHeader": "Basic List Component",
        "fifteen": "Usually you would render lists inside a component.",
        "sixteen": "We can refactor the previous example into a component that accepts an array of numbers and outputs a list of elements.",
        "seventhBlack": "function NumberList(props) {   const numbers = props.numbers;   const listItems = numbers.map((number) =>   <li>{number}</li>   );   return (   <ul>{listItems}</ul>   );   }   const numbers = [1, 2, 3, 4, 5];   const root = ReactDOM.createRoot(document.getElementById('root'));   root.render(<NumberList numbers={numbers} />);",
        "eighteen": "When you run this code, you’ll be given a warning that a key should be provided for list items. A “key” is a special string attribute you need to include when creating lists of elements. We’ll discuss why it’s important in the next section.",
        "nineteen": "Let’s assign a key to our list items inside numbers.map() and fix the missing key issue.",
        "twentyBlack": "function NumberList(props) {   const numbers = props.numbers;   const listItems = numbers.map((number) =>   <li key={number.toString()}>   {number}   </li>   );   return (   <ul>{listItems}</ul>   );   }"
    },
    {
        "category": "MAIN CONCEPTS",
        "title": "Forms",
        "firstYellow": "Try the new React documentation.   These new documentation pages teach modern React and include live examples:   <input>   <select>   <textarea>   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "second": "HTML form elements work a bit differently from other DOM elements in React, because form elements naturally keep some internal state. For example, this form in plain HTML accepts a single name:",
        "thirdBlack": "<form>   <label>   Name:   <input type='text' name='name' />   </label>   <input type='submit' value='Submit' />   </form>",
        "forth": "This form has the default HTML form behavior of browsing to a new page when the user submits the form. If you want this behavior in React, it just works. But in most cases, it’s convenient to have a JavaScript function that handles the submission of the form and has access to the data that the user entered into the form. The standard way to achieve this is with a technique called “controlled components”.",
        "fifthHeader": "Controlled Components",
        "sixth": "In HTML, form elements such as <input>, <textarea>, and <select> typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with setState().",
        "seventh": "We can combine the two by making the React state be the “single source of truth”. Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a “controlled component”.",
        "eighth": "For example, if we want to make the previous example log the name when it is submitted, we can write the form as a controlled component:",
        "ninethBlack": "class NameForm extends React.Component {   constructor(props) {   super(props);   this.state = {value: ''};   this.handleChange = this.handleChange.bind(this);   this.handleSubmit = this.handleSubmit.bind(this);   }   handleChange(event) {   this.setState({value: event.target.value});   }   handleSubmit(event) {   alert('A name was submitted: ' + this.state.value);   event.preventDefault();   }   render() {   return (   <form onSubmit={this.handleSubmit}>   <label>   Name:   <input type='text' value={this.state.value} onChange={this.handleChange} />   </label>   <input type='submit' value='Submit' />   </form>   );   }   }",
        "tenth": "Try it on CodePen",
        "eleventh": "Since the value attribute is set on our form element, the displayed value will always be this.state.value, making the React state the source of truth. Since handleChange runs on every keystroke to update the React state, the displayed value will update as the user types.",
        "twelve": "With a controlled component, the input’s value is always driven by the React state. While this means you have to type a bit more code, you can now pass the value to other UI elements too, or reset it from other event handlers.",
        "thirteen": "The textarea Tag",
        "fourteen": "In HTML, a <textarea> element defines its text by its children:",
        "fifteenBlack": "<textarea>   Hello there, this is some text in a text area   </textarea>",
        "sixteen": "In React, a <textarea> uses a value attribute instead. This way, a form using a <textarea> can be written very similarly to a form that uses a single-line input:",
        "seventeenBlack": "class EssayForm extends React.Component {   constructor(props) {   super(props);   this.state = {   value: 'Please write an essay about your favorite DOM element.'   };   this.handleChange = this.handleChange.bind(this);   this.handleSubmit = this.handleSubmit.bind(this);   }   handleChange(event) {   this.setState({value: event.target.value});   }   handleSubmit(event) {   alert('An essay was submitted: ' + this.state.value);   event.preventDefault();   }   render() {   return (   <form onSubmit={this.handleSubmit}>   <label>   Essay:   <textarea value={this.state.value} onChange={this.handleChange} />   </label>   <input type='submit' value='Submit' />   </form>   );   }   }",
        "eighteen": "Notice that this.state.value is initialized in the constructor, so that the text area starts off with some text in it."
    },
    {
        "category": "MAIN CONCEPTS",
        "title": "Lifting State Up",
        "firstYellow": "Try the new React documentation.   These new documentation pages teach modern React and include live examples:   Sharing State Between Components   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "second": "Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. Let’s see how this works in action.",
        "third": "In this section, we will create a temperature calculator that calculates whether the water would boil at a given temperature.",
        "forth": "We will start with a component called BoilingVerdict. It accepts the celsius temperature as a prop, and prints whether it is enough to boil the water:",
        "fifthBlack": "function BoilingVerdict(props) {   if (props.celsius >= 100) {   return <p>The water would boil.</p>;   }   return <p>The water would not boil.</p>;   }",
        "sixth": "Next, we will create a component called Calculator. It renders an <input> that lets you enter the temperature, and keeps its value in this.state.temperature.",
        "seventh": "Additionally, it renders the BoilingVerdict for the current input value.",
        "eighthBlack": "class Calculator extends React.Component {   constructor(props) {   super(props);   this.handleChange = this.handleChange.bind(this);   this.state = {temperature: ''};   }   handleChange(e) {   this.setState({temperature: e.target.value});   }   render() {   const temperature = this.state.temperature;   return (   <fieldset>   <legend>Enter temperature in Celsius:</legend>   <input   value={temperature}   onChange={this.handleChange} />   <BoilingVerdict   celsius={parseFloat(temperature)} />   </fieldset>   );   }   }",
        "nineth": "Try it on CodePen",
        "tenthHeader": "Adding a Second Input",
        "eleventh": "Our new requirement is that, in addition to a Celsius input, we provide a Fahrenheit input, and they are kept in sync.",
        "twelve": "We can start by extracting a TemperatureInput component from Calculator. We will add a new scale prop to it that can either be 'c' or 'f':",
        "thirteenBlack": "const scaleNames = {   c: 'Celsius',   f: 'Fahrenheit'   };   class TemperatureInput extends React.Component {   constructor(props) {   super(props);   this.handleChange = this.handleChange.bind(this);   this.state = {temperature: ''};   }   handleChange(e) {   this.setState({temperature: e.target.value});   }   render() {   const temperature = this.state.temperature;   const scale = this.props.scale;   return (   <fieldset>   <legend>Enter temperature in {scaleNames[scale]}:</legend>   <input value={temperature}   onChange={this.handleChange} />   </fieldset>   );   }  }",
        "fourteen": "We can now change the Calculator to render two separate temperature inputs:",
        "fifteenBlack": "class Calculator extends React.Component {   render() {   return (   <div>   <TemperatureInput scale='c' />   <TemperatureInput scale='f' />   </div>   );   }   }",
        "sixteen": "Try it on CodePen",
        "seventeen": "We have two inputs now, but when you enter the temperature in one of them, the other doesn’t update. This contradicts our requirement: we want to keep them in sync.",
        "eighteen": "We also can’t display the BoilingVerdict from Calculator. The Calculator doesn’t know the current temperature because it is hidden inside the TemperatureInput.",
        "nineteen": "Lifting State Up",
        "twenty": "Currently, both TemperatureInput components independently keep their values in the local state:",
        "twentyOneBlack": "class TemperatureInput extends React.Component {   constructor(props) {   super(props);   this.handleChange = this.handleChange.bind(this);   this.state = {temperature: ''};   }   handleChange(e) {   this.setState({temperature: e.target.value});   }   render() {   const temperature = this.state.temperature;   // ...",
        "twentyTwo": "However, we want these two inputs to be in sync with each other. When we update the Celsius input, the Fahrenheit input should reflect the converted temperature, and vice versa.",
        "twentyThree": "In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called “lifting state up”. We will remove the local state from the TemperatureInput and move it into the Calculator instead.",
        "twentyFour": "If the Calculator owns the shared state, it becomes the “source of truth” for the current temperature in both inputs. It can instruct them both to have values that are consistent with each other. Since the props of both TemperatureInput components are coming from the same parent Calculator component, the two inputs will always be in sync."
    },
    {
        "category":"MAIN CONCEPTS",
        "title": "Composition vs Inheritance",
        "first": "React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components.",
        "second": "In this section, we will consider a few problems where developers new to React often reach for inheritance, and show how we can solve them with composition.",
        "thirdHeader": "Containment",
        "forth": "Some components don’t know their children ahead of time. This is especially common for components like Sidebar or Dialog that represent generic “boxes”.",
        "fifth": "We recommend that such components use the special children prop to pass children elements directly into their output:",
        "sixthBlack": "function FancyBorder(props) {   return (   <div className={'FancyBorder FancyBorder-' + props.color}>   {props.children}   </div>   );   }",
        "seventh": "This lets other components pass arbitrary children to them by nesting the JSX:",
        "eighthBlack": "function WelcomeDialog() {   return (   <FancyBorder color='blue'>   <h1 className='Dialog-title'>   Welcome   </h1>   <p className='Dialog-message'>   Thank you for visiting our spacecraft!   </p>   </FancyBorder>   );   }",
        "nineth": "Try it on CodePen",
        "tenth": "Anything inside the <FancyBorder> JSX tag gets passed into the FancyBorder component as a children prop. Since FancyBorder renders {props.children} inside a <div>, the passed elements appear in the final output.",
        "eleventh": "While this is less common, sometimes you might need multiple “holes” in a component. In such cases you may come up with your own convention instead of using children:",
        "twelveBlack": "function SplitPane(props) {   return (   <div className='SplitPane'>   <div className='SplitPane-left'>   {props.left}   </div>   <div className='SplitPane-right'>   {props.right}   </div>   </div>   );   }   function App() {   return (   <SplitPane   left={   <Contacts />   }   right={   <Chat />   } />   );   }",
        "thirteen": "Try it on CodePen",
        "fourteen": "React elements like <Contacts /> and <Chat /> are just objects, so you can pass them as props like any other data. This approach may remind you of “slots” in other libraries but there are no limitations on what you can pass as props in React.",
        "fifteen": "Specialization",
        "sixteen": "Sometimes we think about components as being “special cases” of other components. For example, we might say that a WelcomeDialog is a special case of Dialog.",
        "seventeen": "In React, this is also achieved by composition, where a more “specific” component renders a more “generic” one and configures it with props:",
        "eighteenBlack": "function Dialog(props) {   return (   <FancyBorder color='blue'>   <h1 className='Dialog-title'>   {props.title}   </h1>   <p className='Dialog-message'>   {props.message}   </p>   </FancyBorder>   );   }   function WelcomeDialog() {   return (   <Dialog   title='Welcome'   message='Thank you for visiting our spacecraft!' />   );   }",
        "nineteen": "Try it on CodePen",
        "twenty": "Composition works equally well for components defined as classes:",
        "twentyOneBlack": "function Dialog(props) {   return (   <FancyBorder color='blue'>   <h1 className='Dialog-title'>   {props.title}   </h1>   <p className='Dialog-message'>   {props.message}   </p>   {props.children}   </FancyBorder>   );   }   class SignUpDialog extends React.Component {   constructor(props) {   super(props);   this.handleChange = this.handleChange.bind(this);   this.handleSignUp = this.handleSignUp.bind(this);   this.state = {login: ''};   }   render() {   return (   <Dialog title='Mars Exploration Program'   message='How should we refer to you?'>   <input value={this.state.login}   onChange={this.handleChange} />   <button onClick={this.handleSignUp}>   Sign Me Up!   </button>   </Dialog>   );   }   handleChange(e) {   this.setState({login: e.target.value});   }   handleSignUp() {   alert(`Welcome aboard, ${this.state.login}!`);   }   }",
        "twentyTwoHeader": "So What About Inheritance?",
        "twentyThree": "At Facebook, we use React in thousands of components, and we haven’t found any use cases where we would recommend creating component inheritance hierarchies.",
        "twentyFour": "Props and composition give you all the flexibility you need to customize a component’s look and behavior in an explicit and safe way. Remember that components may accept arbitrary props, including primitive values, React elements, or functions.",
        "twentyFive": "If you want to reuse non-UI functionality between components, we suggest extracting it into a separate JavaScript module. The components may import it and use that function, object, or class, without extending it."
    },
    {
        "category": "MAIN CONCEPTS",
        "title": "Thinking in React",
        "firstYellow": "Try the new React documentation.   The updated Thinking in React guide teaches modern React and includes live examples.   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "second": "React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram.",
        "third": "One of the many great parts of React is how it makes you think about apps as you build them. In this document, we’ll walk you through the thought process of building a searchable product data table using React.",
        "forthHeader": "Start With A Mock",
        "fifth": "Imagine that we already have a JSON API and a mock from our designer. The mock looks like this:",
        "sixthImg": "https://reactjs.org/static/1071fbcc9eed01fddc115b41e193ec11/d4770/thinking-in-react-mock.png",
        "seventh": "Our JSON API returns some data that looks like this:",
        "eighthBlack": "[   {category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football'},   {category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball'},   {category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball'},   {category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch'},   {category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5'},   {category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7'}   ];",
        "ninethHeader": "Step 1: Break The UI Into A Component Hierarchy",
        "tenth": "The first thing you’ll want to do is to draw boxes around every component (and subcomponent) in the mock and give them all names. If you’re working with a designer, they may have already done this, so go talk to them! Their Photoshop layer names may end up being the names of your React components!",
        "eleventh": "But how do you know what should be its own component? Use the same techniques for deciding if you should create a new function or object. One such technique is the single responsibility principle, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents.",
        "twelve": "Since you’re often displaying a JSON data model to a user, you’ll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely. That’s because UI and data models tend to adhere to the same information architecture. Separate your UI into components, where each component matches one piece of your data model.",
        "thirteenImgTwo": "https://reactjs.org/static/9381f09e609723a8bb6e4ba1a7713b46/90cbd/thinking-in-react-components.png",
        "fourteen": "You’ll see here that we have five components in our app. We’ve italicized the data each component represents. The numbers in the image correspond to the numbers below.",
        "fifteenNumber": "FilterableProductTable (orange): contains the entirety of the example   SearchBar (blue): receives all user input   ProductTable (green): displays and filters the data collection based on user input   ProductCategoryRow (turquoise): displays a heading for each category   ProductRow (red): displays a row for each product",
        "sixteen": "If you look at ProductTable, you’ll see that the table header (containing the “Name” and “Price” labels) isn’t its own component. This is a matter of preference, and there’s an argument to be made either way. For this example, we left it as part of ProductTable because it is part of rendering the data collection which is ProductTable’s responsibility. However, if this header grows to be complex (e.g., if we were to add affordances for sorting), it would certainly make sense to make this its own ProductTableHeader component."
    },
    {
        "id":"14",
        "title":"ReactDOM",
        "category":"apireference",
        "titleSummary":"The react-dom package provides DOM-specific methods that can be used at the top level of your app and as an escape hatch to get outside the React model if you need to.",
        "domcode1":"import * as ReactDOM from 'react-dom';",
        "titleSummary1":"If you use ES5 with npm, you can write:",
        "domcode2":"var ReactDOM = require('react-dom');",
        "title1":"Overview",
        "title1des":"The react-dom package exports these methods:   createPortal()   flushSync()   These react-dom methods are also exported, but are considered legacy:   render()   hydrate()   findDOMNode()   unmountComponentAtNode()",
        "yellotitle":"Note:   Both render and hydrate have been replaced with new client methods in React 18. These methods will warn that your app will behave as if it’s running React 17 (learn more here).",
        "title2":"Legacy Reference",
        "yellotitle2":"Note:   render() controls the contents of the container node you pass in. Any existing DOM elements inside are replaced when first called. Later calls use React’s DOM diffing algorithm for efficient updates.   render() does not modify the container node (only modifies the children of the container). It may be possible to insert a component to an existing DOM node without overwriting the existing children.   render() currently returns a reference to the root ReactComponent instance. However, using this return value is legacy and should be avoided because future versions of React may render components asynchronously in some cases. If you need a reference to the root ReactComponent instance, the preferred solution is to attach a callback ref to the root element.   Using render() to hydrate a server-rendered container is deprecated. Use hydrateRoot() instead.",
        "title2des":"Same as render(), but is used to hydrate a container whose HTML contents were rendered by ReactDOMServer. React will attempt to attach event listeners to the existing markup.   React expects that the rendered content is identical between the server and the client. It can patch up differences in text content, but you should treat mismatches as bugs and fix them. In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.   If a single element’s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the warning by adding suppressHydrationWarning={true} to the element. It only works one level deep, and is intended to be an escape hatch. Don’t overuse it. Unless it’s text content, React still won’t attempt to patch it up, so it may remain inconsistent until future updates.   If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a state variable like this.state.isClient, which you can set to true in componentDidMount(). This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration. Note that this approach will make your components slower because they have to render twice, so use it with caution.   Remember to be mindful of user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so if you render something different in the client-only pass, the transition can be jarring. However, if executed well, it may be beneficial to render a “shell” of the application on the server, and only show some of the extra widgets on the client. To learn how to do this without getting the markup mismatch issues, refer to the explanation in the previous paragraph."

    },
    {
        "id":"15",
        "title":"ReactDOMClient",
        "category":"apireference",
        "titleSummary":"The react-dom/client package provides client-specific methods used for initializing an app on the client. Most of your components should not need to use this module.",
        "domcode1":"import * as ReactDOM from 'react-dom/client';",
        "titleSummary1":"If you use ES5 with npm, you can write:",
        "domcode2":"var ReactDOM = require('react-dom/client');",
        "title1":"Overview",
        "title1des":"The following methods can be used in client environments:   createRoot()   hydrateRoot()",
        "title2":"Reference",
        "upyellowtitle":"createRoot()",
        "yellotitle":"Try the new React documentation for createRoot.   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "domcode3":"createRoot(container[, options]);",
        "upcode4":"Create a React root for the supplied container and return the root. The root can be used to render a React element into the DOM with render:",
        "domcode4":"const root = createRoot(container);   root.render(element);",
        "upcode5":"createRoot accepts two options:   onRecoverableError: optional callback called when React automatically recovers from errors.   identifierPrefix: optional prefix React uses for ids generated by React.useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix used on the server.",
        "upcode6":"The root can also be unmounted with unmount:",
        "domcode5":"root.unmount();",
        "yellotitle1":"Note:   createRoot() controls the contents of the container node you pass in. Any existing DOM elements inside are replaced when render is called. Later calls use React’s DOM diffing algorithm for efficient updates.   createRoot() does not modify the container node (only modifies the children of the container). It may be possible to insert a component to an existing DOM node without overwriting the existing children.   Using createRoot() to hydrate a server-rendered container is not supported. Use   hydrateRoot() instead.",
        "upyellowtitle1":"hydrateRoot()",
        "yellotitle2":"Try the new React documentation for hydrateRoot.   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "domcode6":"hydrateRoot(container, element[, options])"
    },
    {
        "id":"16",
        "title":"ReactDOMServer",
        "category":"apireference",
        "titleSummary":"The ReactDOMServer object enables you to render components to static markup. Typically, it’s used on a Node server:",
        "domcode1":"// ES modules   import * as ReactDOMServer from 'react-dom/server';   // CommonJS   var ReactDOMServer = require('react-dom/server');",
        "title1":"Overview",
        "title1des":"These methods are only available in the environments with Node.js Streams:   renderToPipeableStream()   renderToNodeStream() (Deprecated)   renderToStaticNodeStream()   These methods are only available in the environments with Web Streams (this includes browsers, Deno, and some modern edge runtimes):   renderToReadableStream()   The following methods can be used in the environments that don’t support streams:   renderToString()   renderToStaticMarkup()",
        "title2":"Reference",
        "yellotitle":"Try the new React documentation for renderToPipeableStream.   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "domcode3":"ReactDOMServer.renderToPipeableStream(element, options)",
        "upcode4":"Render a React element to its initial HTML. Returns a stream with a pipe(res) method to pipe the output and abort() to abort the request. Fully supports Suspense and streaming of HTML with “delayed” content blocks “popping in” via inline <script> tags later.   If you call ReactDOM.hydrateRoot() on a node that already has this server-rendered markup, React will preserve it and only attach event handlers, allowing you to have a very performant first-load experience.",
        "domcode4":"let didError = false;   const stream = renderToPipeableStream(   <App />,   {   onShellReady() {    // The content above all Suspense boundaries is ready.         // If something errored before we started streaming, we set the error code appropriately.   res.statusCode = didError ? 500 : 200;   res.setHeader('Content-type', 'text/html');   stream.pipe(res);   },   onShellError(error) {   // Something errored before we could complete the shell so we emit an alternative shell.   res.statusCode = 500;   res.send(   '<!doctype html><p>Loading...</p><script src='clientrender.js'></script>'   );   },   onAllReady() {   // If you don't want streaming, use this instead of onShellReady.   // This will fire after the entire page content is ready.   // You can use this for crawlers or static generation.   // res.statusCode = didError ? 500 : 200;   // res.setHeader('Content-type', 'text/html');   // stream.pipe(res);   },   onError(err) {   didError = true;   console.error(err);   },    }   );",
        "upcode5":"Streams a React element to its initial HTML. Returns a Promise that resolves to a Readable Stream. Fully supports Suspense and streaming of HTML.   If you call ReactDOM.hydrateRoot() on a node that already has this server-rendered markup, React will preserve it and only attach event handlers, allowing you to have a very performant first-load experience.",
        "domcode5":"let controller = new AbortController();   let didError = false;   try {   let stream = await renderToReadableStream(   <html>   <body>Success</body>   </html>,   {   signal: controller.signal,   onError(error) {   didError = true;   console.error(error);   }   }   );   // This is to wait for all Suspense boundaries to be ready. You can uncomment   // This is to wait for all Suspense boundaries to be ready. You can uncomment   // this line if you want to buffer the entire HTML instead of streaming it.   // You can use this for crawlers or static generation:   // await stream.allReady;   return new Response(stream, {   status: didError ? 500 : 200,   headers: {'Content-Type': 'text/html'},   });   } catch (error) {   return new Response(   '<!doctype html><p>Loading...</p><script src='clientrender.js'></script>'   {   status: 500,   headers: {'Content-Type': 'text/html'},   }   );   }"
       
    },
    {
        "id":"17",
        "title":"JavaScript Environment Requirements",
        "category":"apireference",
        "titleSummary":"React 18 supports all modern browsers (Edge, Firefox, Chrome, Safari, etc).",
        "titleSummary1":"If you support older browsers and devices such as Internet Explorer which do not provide modern browser features natively or have non-compliant implementations, consider including a global polyfill in your bundled application.",
        "titleSummary2":"Here is a list of the modern features React 18 uses:   Promise   Symbol   Object.assign",
        "titleSummury3":"The correct polyfill for these features depend on your environment. For many users, you can configure your Browserlist settings. For others, you may need to import polyfills like core-js directly."
    },
    {
        "id":"18",
        "title":"Glossary of React Terms",
        "category":"apireference",
        "title1":"Single-page Application",
        "title1des":"A single-page application is an application that loads a single HTML page and all the necessary assets (such as JavaScript and CSS) required for the application to run. Any interactions with the page or subsequent pages do not require a round trip to the server which means the page is not reloaded.   Though you may build a single-page application in React, it is not a requirement. React can also be used for enhancing small parts of existing websites with additional interactivity. Code written in React can coexist peacefully with markup rendered on the server by something like PHP, or with other client-side libraries. In fact, this is exactly how React is being used at Facebook.",
        "title2":"ES6, ES2015, ES2016, etc",
        "title2des":"These acronyms all refer to the most recent versions of the ECMAScript Language Specification standard, which the JavaScript language is an implementation of. The ES6 version (also known as ES2015) includes many additions to the previous versions such as: arrow functions, classes, template literals, let and const statements.",
        "title3":"Compilers",
        "title3des":"A JavaScript compiler takes JavaScript code, transforms it and returns JavaScript code in a different format. The most common use case is to take ES6 syntax and transform it into syntax that older browsers are capable of interpreting. Babel is the compiler most commonly used with React.",
        "title4":"Bundlers",
        "title4des":"Bundlers take JavaScript and CSS code written as separate modules (often hundreds of them), and combine them together into a few files better optimized for the browsers. Some bundlers commonly used in React applications include Webpack and Browserify.",
        "title5":"Package Managers",
        "title5des":"Package managers are tools that allow you to manage dependencies in your project. npm and Yarn are two package managers commonly used in React applications. Both of them are clients for the same npm package registry.",
        "title6":"CDN",
        "title6des":"CDN stands for Content Delivery Network. CDNs deliver cached, static content from a network of servers across the globe.",
        "title7":"JSX",
        "title7des":"JSX is a syntax extension to JavaScript. It is similar to a template language, but it has full power of JavaScript. JSX gets compiled to React.createElement() calls which return plain JavaScript objects called “React elements”. To get a basic introduction to JSX see the docs here and find a more in-depth tutorial on JSX here.   React DOM uses camelCase property naming convention instead of HTML attribute names. For example, tabindex becomes tabIndex in JSX. The attribute class is also written as className since class is a reserved word in JavaScript:",
        "domcode7":"<h1 className='hello'>My name is Clementine!</h1>",
        "title8":"Keys",
        "title8des":"A “key” is a special string attribute you need to include when creating arrays of elements. Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside an array to give the elements a stable identity.   Keys only need to be unique among sibling elements in the same array. They don’t need to be unique across the whole application or even a single component.   Don’t pass something like Math.random() to keys. It is important that keys have a “stable identity” across re-renders so that React can determine when items are added, removed, or re-ordered. Ideally, keys should correspond to unique and stable identifiers coming from your data, such as post.id."
    },
    {
        "category": "hooks",
        "title": "Introducing Hooks",
        "firstHeading": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.",
        "secondCode": "import React, { useState } from 'react';   function Example() {   // Declare a new state variable, which we'll call 'count'   const [count, setCount] = useState(0);   return (   <div>   <p>You clicked {count} times</p>   <button onClick={() => setCount(count + 1)}>   Click me   </button>   </div>   );   }",
        "third": "This new function useState is the first “Hook” we’ll learn about, but this example is just a teaser. Don’t worry if it doesn’t make sense yet!   You can start learning Hooks on the next page. On this page, we’ll continue by explaining why we’re adding Hooks to React and how they can help you write great applications.",
        "fourYellow": "Note   React 16.8.0 is the first release to support Hooks. When upgrading, don’t forget to update all packages, including React DOM. React Native has supported Hooks since the 0.59 release of React Native.",
        "fiveSubTitle": "No Breaking Changes",
        "six": "Before we continue, note that Hooks are:   1.Completely opt-in. You can try Hooks in a few components without rewriting any existing code. But you don’t have to learn or use Hooks right now if you don’t want to.   2.100% backwards-compatible. Hooks don’t contain any breaking changes.   3.Available now. Hooks are now available with the release of v16.8.0.   There are no plans to remove classes from React. You can read more about the gradual adoption strategy for Hooks in the bottom section of this page.   Hooks don’t replace your knowledge of React concepts. Instead, Hooks provide a more direct API to the React concepts you already know: props, state, context, refs, and lifecycle. As we will show later, Hooks also offer a new powerful way to combine them.   If you just want to start learning Hooks, feel free to jump directly to the next page! You can also keep reading this page to learn more about why we’re adding Hooks, and how we’re going to start using them without rewriting our applications.",
        "sevenSubTitle": "Motivation",
        "eight": "Hooks solve a wide variety of seemingly unconnected problems in React that we’ve encountered over five years of writing and maintaining tens of thousands of components. Whether you’re learning React, use it daily, or even prefer a different library with a similar component model, you might recognize some of these problems.",
        "nineHeading": "It’s hard to reuse stateful logic between components",
        "ten": "React doesn’t offer a way to “attach” reusable behavior to a component (for example, connecting it to a store). If you’ve worked with React for a while, you may be familiar with patterns like render props and higher-order components that try to solve this. But these patterns require you to restructure your components when you use them, which can be cumbersome and make code harder to follow. If you look at a typical React application in React DevTools, you will likely find a “wrapper hell” of components surrounded by layers of providers, consumers, higher-order components, render props, and other abstractions. While we could filter them out in DevTools, this points to a deeper underlying problem: React needs a better primitive for sharing stateful logic.   With Hooks, you can extract stateful logic from a component so it can be tested independently and reused. Hooks allow you to reuse stateful logic without changing your component hierarchy. This makes it easy to share Hooks among many components or with the community.   We’ll discuss this more in Building Your Own Hooks.",
        "elevenHeading": "Complex components become hard to understand",
        "twelve": "We’ve often had to maintain components that started out simple but grew into an unmanageable mess of stateful logic and side effects. Each lifecycle method often contains a mix of unrelated logic. For example, components might perform some data fetching in componentDidMount and componentDidUpdate. However, the same componentDidMount method might also contain some unrelated logic that sets up event listeners, with cleanup performed in componentWillUnmount. Mutually related code that changes together gets split apart, but completely unrelated code ends up combined in a single method. This makes it too easy to introduce bugs and inconsistencies.   In many cases it’s not possible to break these components into smaller ones because the stateful logic is all over the place. It’s also difficult to test them. This is one of the reasons many people prefer to combine React with a separate state management library. However, that often introduces too much abstraction, requires you to jump between different files, and makes reusing components more difficult.   To solve this, Hooks let you split one component into smaller functions based on what pieces are related (such as setting up a subscription or fetching data), rather than forcing a split based on lifecycle methods. You may also opt into managing the component’s local state with a reducer to make it more predictable.   We’ll discuss this more in Using the Effect Hook.",
        "thirteenSubTitle": "Classes confuse both people and machines",
        "fourteen": "In addition to making code reuse and code organization more difficult, we’ve found that classes can be a large barrier to learning React. You have to understand how this works in JavaScript, which is very different from how it works in most languages. You have to remember to bind the event handlers. Without ES2022 public class fields, the code is very verbose. People can understand props, state, and top-down data flow perfectly well but still struggle with classes. The distinction between function and class components in React and when to use each one leads to disagreements even between experienced React developers.   Additionally, React has been out for about five years, and we want to make sure it stays relevant in the next five years. As Svelte, Angular, Glimmer, and others show, ahead-of-time compilation of components has a lot of future potential. Especially if it’s not limited to templates. Recently, we’ve been experimenting with component folding using Prepack, and we’ve seen promising early results. However, we found that class components can encourage unintentional patterns that make these optimizations fall back to a slower path. Classes present issues for today’s tools, too. For example, classes don’t minify very well, and they make hot reloading flaky and unreliable. We want to present an API that makes it more likely for code to stay on the optimizable path.   To solve these problems, Hooks let you use more of React’s features without classes. Conceptually, React components have always been closer to functions. Hooks embrace functions, but without sacrificing the practical spirit of React. Hooks provide access to imperative escape hatches and don’t require you to learn complex functional or reactive programming techniques.",
        "fifteenYellow": "Examples   Hooks at a Glance is a good place to start learning Hooks.",
        "sixteenSubTitle": "Gradual Adoption Strategy",
        "seventeenYellow": "TLDR: There are no plans to remove classes from React.",
        "eighteen": "We know that React developers are focused on shipping products and don’t have time to look into every new API that’s being released. Hooks are very new, and it might be better to wait for more examples and tutorials before considering learning or adopting them   We also understand that the bar for adding a new primitive to React is extremely high. For curious readers, we have prepared a detailed RFC that dives into the motivation with more details, and provides extra perspective on the specific design decisions and related prior art.   Crucially, Hooks work side-by-side with existing code so you can adopt them gradually. There is no rush to migrate to Hooks. We recommend avoiding any “big rewrites”, especially for existing, complex class components. It takes a bit of a mind shift to start “thinking in Hooks”. In our experience, it’s best to practice using Hooks in new and non-critical components first, and ensure that everybody on your team feels comfortable with them. After you give Hooks a try, please feel free to send us feedback, positive or negative.   We intend for Hooks to cover all existing use cases for classes, but we will keep supporting class components for the foreseeable future. At Facebook, we have tens of thousands of components written as classes, and we have absolutely no plans to rewrite them. Instead, we are starting to use Hooks in the new code side by side with classes."
    },
    {
        "category": "hooks",
        "title": "Hooks at a Glance",
        "oneHeading": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.",
        "two": "Hooks are backwards-compatible. This page provides an overview of Hooks for experienced React users. This is a fast-paced overview. If you get confused, look for a yellow box like this:",
        "threeYellow": "Detailed Explanation   Read the Motivation to learn why we’re introducing Hooks to React.",
        "fourSubTitle": "State Hook",
        "five": "This example renders a counter. When you click the button, it increments the value:",
        "sixCode": "import React, { useState } from 'react';   function Example() {   // Declare a new state variable, which we'll call 'count'   const [count, setCount] = useState(0);   return (   <div>   <p>You clicked {count} times</p>   <button onClick={() => setCount(count + 1)}>   Click me   </button>   </div>   );   }",
        "seven": "Here, useState is a Hook (we’ll talk about what this means in a moment). We call it inside a function component to add some local state to it. React will preserve this state between re-renders. useState returns a pair: the current state value and a function that lets you update it. You can call this function from an event handler or somewhere else. It’s similar to this.setState in a class, except it doesn’t merge the old and new state together. (We’ll show an example comparing useState to this.state in Using the State Hook.)   The only argument to useState is the initial state. In the example above, it is 0 because our counter starts from zero. Note that unlike this.state, the state here doesn’t have to be an object — although it can be if you want. The initial state argument is only used during the first render.",
        "eight": "Declaring multiple state variables   You can use the State Hook more than once in a single component:",
        "nineCode": "function ExampleWithManyStates() {   // Declare multiple state variables!   const [age, setAge   ] = useState(42);   const [fruit, setFruit ] = useState('banana');   const [todos, setTodos ] = useState([ { text: 'Learn Hooks' }]);   // ...   }",
        "ten": "But what is a Hook?   Hooks are functions that let you “hook into” React state and lifecycle features from function components. Hooks don’t work inside classes — they let you use React without classes. (We don’t recommend rewriting your existing components overnight but you can start using Hooks in the new ones if you’d like.)   React provides a few built-in Hooks like useState. You can also create your own Hooks to reuse stateful behavior between different components. We’ll look at the built-in Hooks first.",
        "elevenYellow": "Detailed Explanation   You can learn more about the State Hook on a dedicated page: Using the State Hook.",
        "twelveSubTitle": " Effect Hook",
        "thirteen": "You’ve likely performed data fetching, subscriptions, or manually changing the DOM from React components before. We call these operations “side effects” (or “effects” for short) because they can affect other components and can’t be done during rendering.   The Effect Hook, useEffect, adds the ability to perform side effects from a function component. It serves the same purpose as componentDidMount, componentDidUpdate, and componentWillUnmount in React classes, but unified into a single API. (We’ll show examples comparing useEffect to these methods in Using the Effect Hook.)   For example, this component sets the document title after React updates the DOM:",
        "fourteen": "import React, { useState, useEffect } from 'react';   function Example() {   const [count, setCount] = useState(0);   // Similar to componentDidMount and componentDidUpdate:   useEffect(() => {   // Update the document title using the browser API   document.title = `You clicked ${count} times`;   });   return (   <div>   <p>You clicked {count} times</p>   <button onClick={() => setCount(count + 1)}>   Click me   </button>   </div>   );   }",
        "fifteen": "When you call useEffect, you’re telling React to run your “effect” function after flushing changes to the DOM. Effects are declared inside the component so they have access to its props and state. By default, React runs the effects after every render — including the first render. (We’ll talk more about how this compares to class lifecycles in Using the Effect Hook.)   Effects may also optionally specify how to “clean up” after them by returning a function. For example, this component uses an effect to subscribe to a friend’s online status, and cleans up by unsubscribing from it:",
        "sixteenCode": "import React, { useState, useEffect } from 'react';   function FriendStatus(props) {   const [isOnline, setIsOnline] = useState(null);   function handleStatusChange(status) {   setIsOnline(status.isOnline);   }   useEffect(() => {   ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);   return () => {   ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);   };   });   if (isOnline === null) {   return 'Loading...';   }   return isOnline ? 'Online' : 'Offline';   }",
        "seventeenSubTitle": "Rules of Hooks",
        "eighteen": "Hooks are JavaScript functions, but they impose two additional rules:   Only call Hooks at the top level. Don’t call Hooks inside loops, conditions, or nested functions.   Only call Hooks from React function components. Don’t call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks — your own custom Hooks. We’ll learn about them in a moment.)   We provide a linter plugin to enforce these rules automatically. We understand these rules might seem limiting or confusing at first, but they are essential to making Hooks work well.",
        "nineteenYellow": "Detailed Explanation   You can learn more about these rules on a dedicated page: Rules of Hooks.",
        "twentySubTitle": "Building Your Own Hooks",
        "twentyOne": "Sometimes, we want to reuse some stateful logic between components. Traditionally, there were two popular solutions to this problem: higher-order components and render props. Custom Hooks let you do this, but without adding more components to your tree.   Earlier on this page, we introduced a FriendStatus component that calls the useState and useEffect Hooks to subscribe to a friend’s online status. Let’s say we also want to reuse this subscription logic in another component.   First, we’ll extract this logic into a custom Hook called useFriendStatus:",
        "twentyTwoCode": "import React, { useState, useEffect } from 'react';   function useFriendStatus(friendID) {   const [isOnline, setIsOnline] = useState(null);   function handleStatusChange(status) {   setIsOnline(status.isOnline);   }   useEffect(() => {   ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);   return () => {   ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);   };   });    return isOnline;   }",
        "twentyThree": "It takes friendID as an argument, and returns whether our friend is online.   Now we can use it from both components:",
        "twentyFourCode": "function FriendStatus(props) {    const isOnline = useFriendStatus(props.friend.id);   if (isOnline === null) {   return 'Loading...';   }   return isOnline ? 'Online' : 'Offline';   }",
        "twentyFiveCode": "function FriendListItem(props) {   const isOnline = useFriendStatus(props.friend.id);   return (   <li style={{ color: isOnline ? 'green' : 'black'}}>   {props.friend.name}   </li>   );   }",
        "twentySix": "The state of each component is completely independent. Hooks are a way to reuse stateful logic, not state itself. In fact, each call to a Hook has a completely isolated state — so you can even use the same custom Hook twice in one component.   Custom Hooks are more of a convention than a feature. If a function’s name starts with ”use” and it calls other Hooks, we say it is a custom Hook. The useSomething naming convention is how our linter plugin is able to find bugs in the code using Hooks.   You can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven’t considered. We are excited to see what custom Hooks the React community will come up with.",
        "twentySevenYellow": "Detailed Explanation   You can learn more about custom Hooks on a dedicated page: Building Your Own Hooks."
    },
    {
        "category": "hooks",
        "title": "Using the State Hook",
        "firstYellow": "Try the new React documentation.   These new documentation pages teach modern React and include live examples:   State: A Component’s Memory   useState   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "second": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.   The introduction page used this example to get familiar with Hooks:",
        "thirdCode": "import React, { useState } from 'react';   function Example() {   // Declare a new state variable, which we'll call 'count'   const [count, setCount] = useState(0);   const [count, setCount] = useState(0);   div>   <p>You clicked {count} times</p>   <button onClick={() => setCount(count + 1)}>   Click me   </button>   </div>   );   }",
        "fourSubTitle": "Equivalent Class Example",
        "five": "If you used classes in React before, this code should look familiar:",
        "sixCode": "class Example extends React.Component {   constructor(props) {   super(props);   this.state = {   count: 0   };   }   render() {   return (   <div>   <p>You clicked {this.state.count} times</p>   <button onClick={() => this.setState({ count: this.state.count + 1 })}>    Click me   </button>   </div>   );   }   }",
        "seven": "The state starts as { count: 0 }, and we increment state.count when the user clicks a button by calling this.setState(). We’ll use snippets from this class throughout the page.",
        "eightYellow": "Note   You might be wondering why we’re using a counter here instead of a more realistic example. This is to help us focus on the API while we’re still making our first steps with Hooks.",
        "nineSubTitle": "Hooks and Function Components",
        "ten": "As a reminder, function components in React look like this:",
        "elevenCode": "const Example = (props) => {   // You can use Hooks here!    return <div />;   }",
        "twelve": "or this:",
        "thirteenCode": "function Example(props) {   // You can use Hooks here!   return <div />;   }",
        "fourteen": "You might have previously known these as “stateless components”. We’re now introducing the ability to use React state from these, so we prefer the name “function components”.   Hooks don’t work inside classes. But you can use them instead of writing classes.",
        "fifteenSubTitle": "What’s a Hook?",
        "sixteen": "Our new example starts by importing the useState Hook from React:",
        "seventeenCode": "import React, { useState } from 'react';   function Example() {   // ...   }",
        "eighteen": "What is a Hook? A Hook is a special function that lets you “hook into” React features. For example, useState is a Hook that lets you add React state to function components. We’ll learn other Hooks later.   When would I use a Hook? If you write a function component and realize you need to add some state to it, previously you had to convert it to a class. Now you can use a Hook inside the existing function component. We’re going to do that right now!",
        "nineteenYellow": "Note:   There are some special rules about where you can and can’t use Hooks within a component. We’ll learn them in Rules of Hooks.",
        "twentySubTitle": "Declaring a State Variable",
        "twentyOne": "In a class, we initialize the count state to 0 by setting this.state to { count: 0 } in the constructor:",
        "twentyTwoCode": "class Example extends React.Component {   constructor(props) {   super(props);   this.state = {   count: 0   };   }",
        "twentyThree": "In a function component, we have no this, so we can’t assign or read this.state. Instead, we call the useState Hook directly inside our component:",
        "twentyFourCode": "import React, { useState } from 'react';   function Example() {   // Declare a new state variable, which we'll call 'count'   const [count, setCount] = useState(0);",
        "twentyFive": "What does calling useState do? It declares a “state variable”. Our variable is called count but we could call it anything else, like banana. This is a way to “preserve” some values between the function calls — useState is a new way to use the exact same capabilities that this.state provides in a class. Normally, variables “disappear” when the function exits but state variables are preserved by React.   What do we pass to useState as an argument? The only argument to the useState() Hook is the initial state. Unlike with classes, the state doesn’t have to be an object. We can keep a number or a string if that’s all we need. In our example, we just want a number for how many times the user clicked, so pass 0 as initial state for our variable. (If we wanted to store two different values in state, we would call useState() twice.)   What does useState return? It returns a pair of values: the current state and a function that updates it. This is why we write const [count, setCount] = useState(). This is similar to this.state.count and this.setState in a class, except you get them in a pair. If you’re not familiar with the syntax we used, we’ll come back to it at the bottom of this page.   Now that we know what the useState Hook does, our example should make more sense:",
        "twentySix": "import React, { useState } from 'react';   function Example() {   // Declare a new state variable, which we'll call 'count'   const [count, setCount] = useState(0);"
    },
    {
        "category": "hooks",
        "title": "Using the Effect Hook",
        "firstYellow": "Try the new React documentation.   These new documentation pages teach modern React and include live examples:   1.Synchronizing with Effects   2.You Might Not Need an Effect   3.useEffect   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "second": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.   The Effect Hook lets you perform side effects in function components:",
        "thirdCode": "import React, { useState, useEffect } from 'react';   function Example() {   const [count, setCount] = useState(0);   // Similar to componentDidMount and componentDidUpdate:   useEffect(() => {    // Update the document title using the browser API   document.title = `You clicked ${count} times`;   });   return (   <div>   <p>You clicked {count} times</p>   <button onClick={() => setCount(count + 1)}>   Click me   </button>   </div>   );   }",
        "four": "This snippet is based on the counter example from the previous page, but we added a new feature to it: we set the document title to a custom message including the number of clicks.   Data fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you’re used to calling these operations “side effects” (or just “effects”), you’ve likely performed them in your components before.",
        "fiveYellow": "Tip   If you’re familiar with React class lifecycle methods, you can think of useEffect Hook as componentDidMount, componentDidUpdate, and componentWillUnmount combined.",
        "six": "There are two common kinds of side effects in React components: those that don’t require cleanup, and those that do. Let’s look at this distinction in more detail.",
        "seventSubTitle": "Effects Without Cleanup",
        "eight": "Sometimes, we want to run some additional code after React has updated the DOM. Network requests, manual DOM mutations, and logging are common examples of effects that don’t require a cleanup. We say that because we can run them and immediately forget about them. Let’s compare how classes and Hooks let us express such side effects.",
        "nineHeading": "In React class components, the render method itself shouldn’t cause side effects. It would be too early — we typically want to perform our effects after React has updated the DOM.   This is why in React classes, we put side effects into componentDidMount and componentDidUpdate. Coming back to our example, here is a React counter class component that updates the document title right after React makes changes to the DOM:",
        "tenCode": "class Example extends React.Component {   constructor(props) {   super(props);   this.state = {   count: 0   };   }   componentDidMount() {   document.title = `You clicked ${this.state.count} times`;   }    componentDidUpdate(){   document.title = `You clicked ${this.state.count } times`;   }   render() {   return (   <div>   <p> You clicked {this.state.count} times </p>   <button onClick={() => this.setState({ count: this.state.count + 1 })}>   Click me   </button>   </div>   );   }   }",
        "eleven": "Note how we have to duplicate the code between these two lifecycle methods in class.   This is because in many cases we want to perform the same side effect regardless of whether the component just mounted, or if it has been updated. Conceptually, we want it to happen after every render — but React class components don’t have a method like this. We could extract a separate method but we would still have to call it in two places.   Now let’s see how we can do the same with the useEffect Hook.",
        "twelveHeading": "Example Using Hooks",
        "thirteen": "We’ve already seen this example at the top of this page, but let’s take a closer look at it:",
        "fourteenCode": "import React, { useState, useEffect } from 'react';   function Example() {   const [count, setCount] = useState(0);   useEffect(() => {    document.title = `You clicked ${count} times`;   });   return (   <div>   <p>You clicked {count} times</p>   <button onClick={() => setCount(count + 1)}>   Click me   </button>   </div>   );   }",
        "fifteen": "What does useEffect do? By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we’ll refer to it as our “effect”), and call it later after performing the DOM updates. In this effect, we set the document title, but we could also perform data fetching or call some other imperative API.   Why is useEffect called inside a component? Placing useEffect inside the component lets us access the count state variable (or any props) right from the effect. We don’t need a special API to read it — it’s already in the function scope. Hooks embrace JavaScript closures and avoid introducing React-specific APIs where JavaScript already provides a solution.   Does useEffect run after every render? Yes! By default, it runs both after the first render and after every update. (We will later talk about how to customize this.) Instead of thinking in terms of “mounting” and “updating”, you might find it easier to think that effects happen “after render”. React guarantees the DOM has been updated by the time it runs the effects.",
        "sixteenTitle": "Detailed Explanation",
        "seventeen": "Now that we know more about effects, these lines should make sense:",
        "eighteenCode": "function Example() {   const [count, setCount] = useState(0);   useEffect(() => {   document.title = `You clicked ${count} times`;   });   }",
        "nineteen": "We declare the count state variable, and then we tell React we need to use an effect. We pass a function to the useEffect Hook. This function we pass is our effect. Inside our effect, we set the document title using the document.title browser API. We can read the latest count inside the effect because it’s in the scope of our function. When React renders our component, it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.   Experienced JavaScript developers might notice that the function passed to useEffect is going to be different on every render. This is intentional. In fact, this is what lets us read the count value from inside the effect without worrying about it getting stale. Every time we re-render, we schedule a different effect, replacing the previous one. In a way, this makes the effects behave more like a part of the render result — each effect “belongs” to a particular render. We will see more clearly why this is useful later on this page.",
        "twentyYellow": "Tip   Unlike componentDidMount or componentDidUpdate, effects scheduled with useEffect don’t block the browser from updating the screen. This makes your app feel more responsive. The majority of effects don’t need to happen synchronously. In the uncommon cases where they do (such as measuring the layout), there is a separate useLayoutEffect Hook with an API identical to useEffect."
    },
    {
        "category": "hooks",
        "title": "Rules of Hooks",
        "firstHeading": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.",
        "second": "Hooks are JavaScript functions, but you need to follow two rules when using them. We provide a linter plugin to enforce these rules automatically:",
        "thirdSubTitle": "Only Call Hooks at the Top Level",
        "four": "Don’t call Hooks inside loops, conditions, or nested functions. Instead, always use Hooks at the top level of your React function, before any early returns. By following this rule, you ensure that Hooks are called in the same order each time a component renders. That’s what allows React to correctly preserve the state of Hooks between multiple useState and useEffect calls. (If you’re curious, we’ll explain this in depth below.)",
        "fiveSubTitle": "Only Call Hooks from React Functions",
        "six": "Don’t call Hooks from regular JavaScript functions. Instead, you can:   ✅ Call Hooks from React function components.   ✅ Call Hooks from custom Hooks (we’ll learn about them on the next page).   By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code.",
        "sevenSubTitle": "ESLint Plugin",
        "eight": "We released an ESLint plugin called eslint-plugin-react-hooks that enforces these two rules. You can add this plugin to your project if you’d like to try it:   This plugin is included by default in Create React App.",
        "nineCode": "npm install eslint-plugin-react-hooks --save-dev",
        "tenCode": "// Your ESLint configuration   {   'plugins': [   // ...   'react-hooks'   ],   'rules': {   'react-hooks/rules-of-hooks': 'error', // Checks rules of Hooks   'react-hooks/exhaustive-deps': 'warn // Checks effect dependencies   }   }",
        "eleven": "You can skip to the next page explaining how to write your own Hooks now. On this page, we’ll continue by explaining the reasoning behind these rules.",
        "twelveSubTitle": "Explanation",
        "thirteen": "As we learned earlier, we can use multiple State or Effect Hooks in a single component:",
        "fourteenCode": "function Form() {   // 1. Use the name state variable   const [name, setName] = useState('Mary');   // 2. Use an effect for persisting the form   useEffect(function persistForm() {   localStorage.setItem('formData', name);   });   // 3. Use the surname state variable   const [surname, setSurname] = useState('Poppins');   // 4. Use an effect for updating the title   useEffect(function updateTitle() {   document.title = name + ' ' + surname;   });   // ...   }",
        "fifteen": "So how does React know which state corresponds to which useState call? The answer is that React relies on the order in which Hooks are called. Our example works because the order of the Hook calls is the same on every render:   As long as the order of the Hook calls is the same between renders, React can associate some local state with each of them. But what happens if we put a Hook call (for example, the persistForm effect) inside a condition?",
        "sixteenCode": "// 🔴 We're breaking the first rule by using a Hook in a condition   if (name !== '') {   useEffect(function persistForm() {   localStorage.setItem('formData', name);   });   }",
        "seventeen": "The name !== '' condition is true on the first render, so we run this Hook. However, on the next render the user might clear the form, making the condition false. Now that we skip this Hook during rendering, the order of the Hook calls becomes different:",
        "eighteenCode": "useState('Mary') // 1. Read the name state variable (argument is ignored)   // useEffect(persistForm)  // 🔴 This Hook was skipped!   useState('Poppins') // 🔴 2 (but was 3). Fail to read the surname state variable   useEffect(updateTitle) // 🔴 3 (but was 4). Fail to replace the effect",
        "nineteen": "React wouldn’t know what to return for the second useState Hook call. React expected that the second Hook call in this component corresponds to the persistForm effect, just like during the previous render, but it doesn’t anymore. From that point, every next Hook call after the one we skipped would also shift by one, leading to bugs.   This is why Hooks must be called on the top level of our components. If we want to run an effect conditionally, we can put that condition inside our Hook:",
        "twentyCode": "useEffect(function persistForm() {   // 👍 We're not breaking the first rule anymore   if (name !== '') {   localStorage.setItem('formData', name);   }   });"
    },
    {
        "category": "hooks",
        "title": "Building Your Own Hooks",
        "firstYellow": "Try the new React documentation.   These new documentation pages teach modern React and include live examples:   Reusing Logic with Custom Hooks   The new docs will soon replace this site, which will be archived. Provide feedback.",
        "second": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.   Building your own Hooks lets you extract component logic into reusable functions.   When we were learning about using the Effect Hook, we saw this component from a chat application that displays a message indicating whether a friend is online or offline:",
        "thirdCode": "import React, { useState, useEffect } from 'react';   function FriendStatus(props) {   const [isOnline, setIsOnline] = useState(null);   useEffect(() => {   function handleStatusChange(status) {   setIsOnline(status.isOnline);   }   ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);   return () =>   {ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);   };   });   if (isOnline === null) {   return 'Loading...';   }   return isOnline ? 'Online' : 'Offline';   }"
    }

]