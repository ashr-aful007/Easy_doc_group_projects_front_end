[
    {
        "id": "1",
        "title": "What Is React?",
        "first-pera": "React is a declarative, efficient, and flexible JavaScript library for building user interfaces. It lets you compose complex UIs from small and isolated pieces of code called “components”.",
        "second-pera": "React has a few different kinds of components, but we'll start with React.Component subclasses:",
        "first-code": [
            "class ShoppingList extends React.Component {",
            "render() {",
            "return (",
            "<div className='shopping-list'>",
            "<h1>Shopping List for {this.props.name}</h1>",
            "<ul>",
            "<li>Instagram</li>",
            "<li>WhatsApp</li>",
            "<li>Oculus</li>",
            "</ul>",
            "</div>",
            ");",
            "}",
            "}"
        ],
        "first-code_first-pera": "We’ll get to the funny XML-like tags soon. We use components to tell React what we want to see on the screen. When our data changes, React will efficiently update and re-render our components.",
        "first-code_second-pera": "Here, ShoppingList is a React component class, or React component type. A component takes in parameters, called props (short for “properties”), and returns a hierarchy of views to display via the render method.",
        "first-code_third-pera": "The render method returns a description of what you want to see on the screen. React takes the description and displays the result. In particular, render returns a React element, which is a lightweight description of what to render. Most React developers use a special syntax called “JSX” which makes these structures easier to write. The <div /> syntax is transformed at build time to React.createElement('div'). The example above is equivalent to:",
        "second-code": [
            "return React.createElement('div', {className: 'shopping-list'},",
            "React.createElement('h1', /* ... h1 children ... */),",
            "React.createElement('ul', /* ... ul children ... */));"
        ],
        "second-code_first-pera": "If you’re curious, createElement() is described in more detail in the API reference, but we won’t be using it in this tutorial. Instead, we will keep using JSX.",
        "second-code_second-pera": "JSX comes with the full power of JavaScript. You can put any JavaScript expressions within braces inside JSX. Each React element is a JavaScript object that you can store in a variable or pass around in your program.",
        "second-code_third-pera": "The ShoppingList component above only renders built-in DOM components like <div /> and <li />. But you can compose and render custom React components too. For example, we can now refer to the whole shopping list by writing <ShoppingList />. Each React component is encapsulated and can operate independently; this allows you to build complex UIs from simple components."
    },
    {
        "id": "2",
        "title": "Inspecting the Starter Code",
        "first-pera": "If you’re going to work on the tutorial in your browser, open this code in a new tab: Starter Code. If you’re going to work on the tutorial locally, instead open src/index.js in your project folder (you have already touched this file during the setup).",
        "second-pera": "This Starter Code is the base of what we’re building. We’ve provided the CSS styling so that you only need to focus on learning React and programming the tic-tac-toe game.",
        "third-pera": "The Square component renders a single <button> and the Board renders 9 squares. The Game component renders a board with placeholder values which we'll modify later. There are currently no interactive components."
    },
    {
        "id": "3",
        "title": "Passing Data Through Props",
        "first-pera": "To get our feet wet, let's try passing some data from our Board component to our Square component.",
        "second-pera": "We strongly recommend typing code by hand as you’re working through the tutorial and not using copy/paste. This will help you develop muscle memory and a stronger understanding.",
        "first-code": [
            "class Board extends React.Component {",
            "renderSquare(i) {",
            "return <Square value={i} />;",
            "}",
            "}"
        ],
        "first-code_first-pera": "Congratulations! You've just “passed a prop” from a parent Board component to a child Square component. Passing props is how information flows in React apps, from parents to children."
    },
    {
        "id": "4",
        "title": "Making an Interactive Component",
        "first-pera": "Let’s fill the Square component with an “X” when we click it. First, change the button tag that is returned from the Square component’s render() function to this:",
        "first-code": [
            "class Square extends React.Component {",
            "render() {",
            "return (",
            "<button className='square' onClick={function() { console.log('click'); }}>",
            "{this.props.value}",
            "</button>",
            ");",
            "}",
            "}"
        ],
        "first-code_first-pera": "If you click on a Square now, you should see ‘click’ in your browser’s devtools console.",
        "first-code_second-pera": "To save typing and avoid the confusing behavior of this, we will use the arrow function syntax for event handlers here and further below:",
        "second-code": [
            "class Square extends React.Component {",
            "render() {",
            "return (",
            "<button className='square' onClick={() => console.log('click')>",
            "{this.props.value}",
            "</button>",
            ");",
            "}",
            "}"
        ],
        "second-code_first-pera": "Notice how with onClick={() => console.log('click')}, we’re passing a function as the onClick prop. React will only call this function after a click. Forgetting () => and writing onClick={console.log('click')} is a common mistake, and would fire every time the component re-renders."
    },
    {
        "id": "5",
        "title": "Developer Tools",
        "first-pera": "The React Devtools extension for Chrome and Firefox lets you inspect a React component tree with your browser’s developer tools.",
        "img": "https://reactjs.org/static/41330fe61a925e2c3009be675bdb96a9/f2205/devtools.png",
        "second-pera": "The React DevTools let you check the props and the state of your React components.",
        "third-pera": "After installing React DevTools, you can right-click on any element on the page, click “Inspect” to open the developer tools, and the React tabs (“⚛️ Components” and “⚛️ Profiler”) will appear as the last tabs to the right. Use “⚛️ Components” to inspect the component tree."
    },
    {
        "id": "6",
        "title": "Lifting State Up",
        "first-pera": "Currently, each Square component maintains the game’s state. To check for a winner, we’ll maintain the value of each of the 9 squares in one location.",
        "second-pera": "We may think that Board should just ask each Square for the Square’s state. Although this approach is possible in React, we discourage it because the code becomes difficult to understand, susceptible to bugs, and hard to refactor. Instead, the best approach is to store the game’s state in the parent Board component instead of in each Square. The Board component can tell each Square what to display by passing a prop, just like we did when we passed a number to each Square.",
        "third-pera": "To collect data from multiple children, or to have two child components communicate with each other, you need to declare the shared state in their parent component instead. The parent component can pass the state back down to the children by using props; this keeps the child components in sync with each other and with the parent component.",
        "forth-pera": "Lifting state into a parent component is common when React components are refactored — let’s take this opportunity to try it out. Add a constructor to the Board and set the Board’s initial state to contain an array of 9 nulls corresponding to the 9 squares:",
        "first-code": [
            "class Board extends React.Component {",
            "constructor(props) {",
            "super(props);",
            "this.state = {",
            "squares: Array(9).fill(null),",
            "};",
            "} ",
            "renderSquare(i) {",
            "return <Square value={i} />;",
            "}"
        ]
    },
    {
        "id": "7",
        "title": "Why Immutability Is Important",
        "first-pera": "In the previous code example, we suggested that you create a copy of the squares array using the slice() method instead of modifying the existing array. We’ll now discuss immutability and why immutability is important to learn.",
        "second-pera": "There are generally two approaches to changing data. The first approach is to mutate the data by directly changing the data’s values. The second approach is to replace the data with a new copy which has the desired changes.",
        "third-pera": "Data Change with Mutation",
        "first-code": [
            "var player = {score: 1, name: 'Jeff'};",
            "player.score = 2;",
            "// Now player is {score: 2, name: 'Jeff'}"
        ],
        "first-code_first-pera": "Data Change without Mutation",
        "second-code": [
            "var player = {score: 1, name: 'Jeff'};",
            " ",
            "var newPlayer = Object.assign({}, player, {score: 2});",
            "// Now player is unchanged, but newPlayer is {score: 2, name: 'Jeff'}",
            " ",
            "// Or if you are using object spread syntax, you can write:",
            "// var newPlayer = {...player, score: 2};"
        ]
    },
    {
        "id": "8",
        "title": "Function Components",
        "first-pera": "We’ll now change the Square to be a function component.",
        "second-pera": "In React, function components are a simpler way to write components that only contain a render method and don’t have their own state. Instead of defining a class which extends React.Component, we can write a function that takes props as input and returns what should be rendered. Function components are less tedious to write than classes, and many components can be expressed this way.",
        "third-pera": "Replace the Square class with this function:",
        "first-code": [
            "function Square(props) {",
            "return (",
            "<button className='square' onClick={props.onClick}>",
            "{props.value}",
            "</button>",
            ");",
            "}"
        ]
    },
    {
        "id": "9",
        "title": "Taking Turns",
        "first-pera": "We now need to fix an obvious defect in our tic-tac-toe game: the “O”s cannot be marked on the board.",
        "second-pera": "We’ll set the first move to be “X” by default. We can set this default by modifying the initial state in our Board constructor:",
        "first-code": [
            "class Board extends React.Component {",
            "constructor(props) {",
            "super(props);",
            "this.state = {",
            "squares: Array(9).fill(null),",
            "xIsNext: true,",
            "};",
            "}"
        ],
        "first-code_first-pera": "Each time a player moves, xIsNext (a boolean) will be flipped to determine which player goes next and the game’s state will be saved. We’ll update the Board’s handleClick function to flip the value of xIsNext:",
        "second-code": [
            "handleClick(i) {",
            "const squares = this.state.squares.slice();",
            "squares[i] = this.state.xIsNext ? 'X' : 'O';",
            "this.setState({",
            "squares: squares,",
            "xIsNext: !this.state.xIsNext,",
            "});",
            "}"
        ]
    },
    {
        "id": "10",
        "title": "Declaring a Winner",
        "first-pera": "Now that we show which player’s turn is next, we should also show when the game is won and there are no more turns to make. Copy this helper function and paste it at the end of the file:",
        "first-code": [
            "function calculateWinner(squares) {",
            "    const lines = [",
            "      [0, 1, 2],",
            "      [3, 4, 5],",
            "      [6, 7, 8],",
            "      [0, 3, 6],",
            "      [1, 4, 7],",
            "      [2, 5, 8],",
            "      [0, 4, 8],",
            "      [2, 4, 6],",
            "    ];",
            "    for (let i = 0; i < lines.length; i++) {",
            "      const [a, b, c] = lines[i];",
            "      if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {",
            "        return squares[a];",
            "      }",
            "    }",
            "    return null;",
            "  }"
        ],
        "first-code_first-pera": "Given an array of 9 squares, this function will check for a winner and return 'X', 'O', or null as appropriate.",
        "first-code_second-pera": "We will call calculateWinner(squares) in the Board’s render function to check if a player has won. If a player has won, we can display text such as “Winner: X” or “Winner: O”. We’ll replace the status declaration in Board’s render function with this code:",
        "second-code": [
            "render() {",
            "    const winner = calculateWinner(this.state.squares);",
            "    let status;",
            "    if (winner) {",
            "      status = 'Winner: ' + winner;",
            "    } else {",
            "      status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O');",
            "    }",
            "",
            "    return (",
            "      // the rest has not changed"
        ]
    }
]